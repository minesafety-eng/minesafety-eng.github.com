var store = [{
        "title": "GitHub 블로그 시작하기",
        "excerpt":"기존에 하던 깃 블로그에서 모바일 구간 깨지는 이슈를 수정하고 디자인적인 아쉬움을 보완하고자  하였습니다. 또한 GitBlog 새로운 테마를 세팅하면서 겪었던 어려움을 공유하고 누구나 바로 Github 블로그에 자신의 글을 쉽게 올릴 수 있도록 글을 공유합니다.   Step 1:  깃 블로그란  깃 블로그란  Github 저장소에 저장된 html 파일과 같은 정적 웹 문서들을 GitHub에서 무료로 웹에서 볼 수 있도록 호스팅 서비스를 제공해 주는 것입니다.  때문에 Github을 이용하는 사용자들은 누구나 고유의 정적 웹 사이트 1개를 가질 수 있습니다. 계정이 없다면 Github 에서 Github계정 생성합니다. 계정을 만들고 신규 Repository를 {Git ID}.github.com 으로 세팅합니다.   Please Note: 해당 포스트는 어느 정도 깃의 사용법을 알고 있다는 가정하에 작성하였습니다.      정상적으로 생성되었다면 세팅 메뉴 중 하단 GitHub Pages가 그림과 같이 활성화되어있을 것입니다.   https://github.com/{ Git ID }/{ Repository 이름 }/settings           위 그림과 같이 정상적으로 반영 되었다면 https://{ Git ID }.github.io/ URL 접근 가능합니다.   Step 2: GitBlog와 Jekyll   이러한 Github page에 Jekyll을 결합한다면 좀 더 생산적이고 강력한 블로그를 만들 수 있습니다. Jekyll이란 HTML(.html), Markdown(.md) 등 다양한 포맷의 텍스트들을 읽고 가공하여 자신의 웹 사이트에 바로 게시할 수 있게 해주는 Rubby언어로 만들어진 하나의 텍스트 변환 엔진이라고 보면 됩니다. 쉽게 말해 html을 모르더라도 공부하기 비교적 수월한 markdown 파일을 작성하면 알아서 html파일로 변환되어 웹 서비스를 구축해 준다고 생각하면 됩니다. 지킬을 사용하여 게시글을 작성한다면 웹 사이트를 효율적으로 구성할 수 있습니다. Jekyll은 Github의 내부 엔진이기 때문에 Github page에서도 자연스럽게 동작합니다. 감사하게도 이러한 jekyll을 가지고 사용자들이 다양한 테마를 미리 만들고 공유하여 디자인에 대해 깊은 고민은 하지 않게 해주었습니다. 주소는 아래와 같습니다.    http://jekyllthemes.org/  http://themes.jekyllrc.org/  https://jekyllthemes.io/    필자의 선택은 꾸준한 업데이트가 강점인 https://github.com/mmistakes/minimal-mistakes테마를 선택하였습니다. ReadMe.md파일 안에 해당 테마에 대한 자세한 사용 방법이 기술되어 있습니다.  테마를 Fork뜨거나 Download합니다.  필자는 Fork시 GitHub 녹색 잔디가 심어지지 않아 다운로드 후  작업하였습니다.      다운로드한 minimal-mistakes테마 Zip파일을 Step1에서 생성한 Repository하위에서 압축 해제합니다. 왼쪽 이미지는 압축해제한 파일 이고,  우측 이미지는 모든 build 및 과정이 끝났을 때 Repository에 push 했을 때 최종 파일입니다.      Step 3: 로컬 개발 환경을 위한 루비설치   Jekyll은 하나의 동적 객체 지향 스크립트 프로그래밍 언어인 Ruby로 작성되었기 때문에 로컬 개발 환경 세팅을 위해서는 Rubby 설치가 필요합니다. 필자는 https://rubyinstaller.org/downloads/ 해당 사이트에서 2.5.7 버전으로 받아 설치하였습니다. 이제 minimal-mistakes테마를 다운받고 압축해제 하였던 폴더 위치로 이동합니다. 이 후 cmd창을 열어 아래 명령어를 차례로 실행합니다. 꼭 Gemfile이 있는 위치에서 실행하여야 합니다.       # gem install bundler # bundle  # jekyll serve       정상적으로 설치가 되었다면 이제 http://localhost:4000/ 으로 해당 테마를 확인할 수 있습니다.      Please Note: Rubby 버전에 따라 안되는 케이스가 발생하여 2.5.7로 진행하였습니다. 로컬 서버 포트를 4000에서 다른것으로 바꾸고 싶다면 # jekyll serve –port {원하는 포트 번호} 명령어로 서버를 실행하면 됩니다.   Tip: 기존 로비가 설치되어있고 플러그인 의존성 이슈가 발생하여 특정 버전은 안된다고 나온다면 아래와 같은 명령어로 전체 삭제 후 플러그인 재설치를 해주면 됩니다.   # gem uninstall -aIx ( 설치된 플러그인 전체 삭제 명령어 )  # gem uninstall { 충돌한 플러그인 명 } ( 특정 플러그인 삭제 명령어  )    이제 Git에 push를 진행하기 전에 압축 해제한 파일 중 불필요한 파일들을 삭제하겠습니다.  .github test .editorconfig .gitattributes .travis.yml CHANGELOG.md docs( 샘플 파일들이 들어가 있는  폴더로 우선 나중을 위해 다른 곳으로 옮겨줍니다. )  push를 진행하면 이제 https://{GitID}.github.io 주소로 같은 화면을 볼 수 있습니다.   Step 4: Sample 게시물 확인  이전에 이동했덩 docs폴더안 _post폴더를  우리 _post에 덮어 씌운 후  jekyll 서버를 재시작 합니다.  그렇다면 이제   http://localhost:4000/ 에서  블로그 게시물 디자인에 참고할 만한  다양한 샘플 포스트를 확인할 수 있습니다.    블로그 게시물에 대한 네이밍 규칙은 YEAR-MONTH-DAY-title.md입니다. 추후 _post폴더 아래에 게시물을 작성할 때 해당 형식을 지켜 작성해야합니다.   Please Note   필자는 블로그 페이지 작성이 목적이라  .md파일 작성법 및  Jekyll에 대해 깊게 포스팅 하지 않겠습니다.  .yml로 된 파일이나  .md 같은 markdown언어에 대해서 공부하고 싶을 경우를 대비하여 공식 사이트 주소는 남겨드리겠습니다.    YAML :   https://yaml.org/    Liquid 문법 : https://shopify.github.io/liquid/    Jekyll 폴더구조 :  https://jekyllrb-ko.github.io/docs/structure/       # gem install bundler # bundle  # jekyll serve    Step 5: 프로젝트 세팅  _config.yml 수정   지킬 테마에서 자신의 블로그 페이지에 맞게 커스텀 하기위해 _config.yml 을 수정하였습니다.  웹에대한 기본 지식이 있다면 어디를 수정하면 어디가 반영 될 지 직관적으로 알 수 있게 되어있습니다.  꼭 수정해 주어야 하는 부분만 포스팅 하고 이 외 수정한 부분은 아래 주소에서 확인하시기 바랍니다. https://github.com/minesafety-eng/minesafety-eng.github.com/blob/master/_config.yml     minimal_mistakes_skin    : \"default\" # 태마 색 설정 \"air\", \"aqua\", \"contrast\", \"dark\", \"dirt\", \"neon\", \"mint\", \"plum\", \"sunrise\"   # Site Settings locale                   : \"ko-KR\" title                    : \"JAVA Blog\" # Meta 태그에 들어가는 영역 , masthead_title등이 없으면 기본값으로 나온다. title_separator          : \"&amp;#124;\" # 타이틀 사이 구분자 &lt;title&gt;Welcome to Jekyll | Minimal Mistakes&lt;/title&gt; 해당 형식으로 들어갑니다. subtitle                 : \"Version 1.0\" # 타이틀 아래에 나올 작은 글씨  name                     : \"김석진\" # 맨 하단 이름 찍히는 영역 description              : \"JAVA와 Spring Boot 혹은 Sever등 다양한 개발을 공부하는 블로그\" # Meta 태그에 들어가는 영역  url                      : \"https://minesafety-eng.github.io/\" # GitBlog 호스트 주소 baseurl                  : # subPath https://minesafety-eng.github.io/blog라고 하고 싶을 시 \"/blog\" 라고 적는다. repository               : \"minesafety-eng/minesafety-eng.github.com\" # GitHub username/repo-name   teaser                   : # \"/assets/images/senior-couple-4723737_640.jpg\" # 홈페이지 기본 티져 이미지 logo                     : # 타이틀 옆에 작게 들어갈 이미지. masthead_title           : \"기록하는 개발자 Blog\" # 홈페이지 최 상탄에 들어갈 타이틀 breadcrumbs              : true # 브래드크럼 사용 여부 true, false (default) , _data/ui-text.yml에 다국어 지원 가능합니다. words_per_minute         : 200 # 해당 포스트 읽는데 걸리는 시간을 계산하기 위해 대락 분당 읽는 수가 몇글자가 될지 적는 공간.  # Site Author author:   name             : \"김석진\"    avatar           : \"/assets/images/profile/poto.jpg\" # 프로필 이미지   bio              : \"꾸준히 공부하는 개발자입니다. &lt;br&gt; 블로그 포스트 글에서 잘못된 부분이나 수정했으면 하는 부분, 적극적으로 댓글 남겨주신다면 감사하겠습니다.\"   location         : \"Republic of Korea\"   email            : \"smj0226@kores.or.kr\"   links:     - label: \"Email\"       icon: \"fas fa-fw fa-envelope-square\"       #url: mailto:smj0226@kores.or.kr     - label: \"Website\"       icon: \"fas fa-fw fa-link\"       url: \"http://honbabzone.com/\"     - label: \"Twitter\"       icon: \"fab fa-fw fa-twitter-square\"       # url: \"https://twitter.com/\"     - label: \"Facebook\"       icon: \"fab fa-fw fa-facebook-square\"       url: \"https://www.facebook.com/seokjin.kim.16\"     - label: \"GitHub\"       icon: \"fab fa-fw fa-github\"       url: \"https://github.com/minesafety-eng\"     - label: \"Instagram\"       icon: \"fab fa-fw fa-instagram\"       # url: \"https://instagram.com/\"  # Site Footer footer:   links:     - label: \"Email\"       icon: \"fas fa-fw fa-envelope-square\"       url: mailto:smj0226@kores.or.kr     - label: \"Twitter\"       icon: \"fab fa-fw fa-twitter-square\"       # url:     - label: \"Facebook\"       icon: \"fab fa-fw fa-facebook-square\"       url: \"https://www.facebook.com/seokjin.kim.16\"     - label: \"GitHub\"       icon: \"fab fa-fw fa-github\"       url: \"https://github.com/minesafety-eng\"     - label: \"GitLab\"       icon: \"fab fa-fw fa-gitlab\"       # url:     - label: \"Bitbucket\"       icon: \"fab fa-fw fa-bitbucket\"       # url:     - label: \"Instagram\"       icon: \"fab fa-fw fa-instagram\"       # url:  # Defaults Post들에 적용될 기본 설정들 defaults:   # _posts   - scope:       path: \"\"       type: posts     values:       layout: single       author_profile: true       read_time: true       comments: true       share: true       related: true      # _pages   - scope:       path: \"_pages\"       type: pages     values:       layout: single       author_profile: true    Tip: config.yml  설정에 대한 공식 사이트  https://mmistakes.github.io/minimal-mistakes/docs/configuration/    navigation 설정  기본 파일은 상단 네비게이션 설정이 되어있지 않습니다. _data/navigation.yml, _config.yml 파일, _pages를 수정하여  Categories, Tag, About이 노출되도록 해보겠습니다.   _data/navigation.yml 수정  원하는 네비게이션 url을 설정해 줍니다. http://naver.com과 같이 상대경로가 아닌 절대경로도 가능합니다.  https://github.com/minesafety-eng/minesafety-eng.github.com/blob/master/_data/navigation.yml   main:   - title: \"Categories\"     url: /categories/   - title: \"Tags\"     url: /tags/   - title: \"About\"     url: /about/   - title: \"연도별 포스트\"     url: /posts/   _pages 폴더  및 필요한 .md파일 생성  이제 카테고리, 테그, about 등 필요한 페이지 정보들을 삽입합니다. 요약해서 말하면 permalink에 쓰여진 url로 요청이 들어오면 layout에 지정된 즉 _layout에 존재하는 {파일명}.html을 불러와 삽입합니다. https://github.com/minesafety-eng/minesafety-eng.github.com/tree/master/_pages     category-archive.md에 대한 예시   --- title: \"Posts by Category\" layout: categories permalink: /categories/ author_profile: true ---    _config.yml 수정  하단 defaults: 부분에 _pages 부분을 추가합니다.  https://github.com/minesafety-eng/minesafety-eng.github.com/blob/master/_config.yml   defaults:   # _posts   - scope:       path: \"\"       type: posts     values:       layout: single       author_profile: true       read_time: true       comments: true       share: true       related: true      # _pages   - scope:       path: \"_pages\"       type: pages     values:       layout: single       author_profile: true   js 빌드를 위한 설정  minimal-mistakes 테마의 경우 node.js를 이용하여 js를 쉽게 minify하거나 원하는 js 플러그인들을 하나의 파일로 합칠 수 있습니다. Node.js를 이용하고 싶지 않을 경우 assets/js/main.min.js에 원하는 스크립트 부분을 추가하면 됩니다. 필자는 Node.js까지 설치하고 /assets/js/custom/custom.js로 추가적인 js 파일을 만들고 템플릿에서 사용할 js를 여기에 집어 넣겠습니다.   Node.js 설치  https://nodejs.org/en/ 해당 사이트에서 Node.js 12.14.0 버전을 다운로드 후 인스톨합니다.   package.json 수정  개발환경은 minify 옵션을 제거하고 파일만 합친 형태로 진행하고 배포시에 minify옵션을 설정하도록 세팅 진행하겠습니다.   https://github.com/minesafety-eng/minesafety-eng.github.com/blob/master/package.json     ① devDependencies안에 해당 내용을 추가합니다.  \"concat\": \"^1.0.3\"   ② scripts에 하위 내용 추가  \"watchDev:js\": \"onchange \\\"assets/js/**/*.js\\\" -e \\\"assets/js/main.min.js\\\" -- npm run buildDev:js\", \"concat-js\": \"concat -o assets/js/main.min.js (요약)... assets/js/custom/custom.js(추가부분)\", \"buildDev:js\": \"npm run concat-js &amp;&amp; npm run add-banner\" \"uglify\": \"uglifyjs (요약)... assets/js/custom/custom.js -c -m -o assets/js/main.min.js(추가 부분)\",   cmd창에서 명령어 실행  package.json이 존재하는 위치에서 해당 명령어를 실행 하면 현재 /assets/js/ 아래에 있는 js파일들이 main.min.js에 합쳐서 나옵니다. uglifyjs 옵션에 대해 더 알고자 한다면 아래 문서를 참고하시면 됩니다. http://fibjs.org/ko/docs/awesome/module/uglify-js.md.html   # npm install  개발시  # npm run watchDev:js  배포시  # npm run build:js   SCSS설정  scss문법을 설명하지 않겠습니다. 다만 “/_sass/custom” 위치에 원하는 폴더 및 SCSS파일을 만들고 /_sass/minimal-mistakes.scss 파일 하단에 @import “custom/_cunstomcss”; 같이 작성 한다면 자동으로 컴파일하여 _site/assets/css/main.css으로 들어가게 됩니다. https://github.com/minesafety-eng/minesafety-eng.github.com/blob/master/_sass/minimal-mistakes.scss  /* Custom */ @import \"custom/_cunstomcss\";   Step 6: Admin 세팅  게시글을  md문법으로 작성하면 되지만 뭔가 불편하여 찾아보니 admin페이지를 통해 쉽게 게시글을 작성할 수 있다는 것을 알게 되어 방법을 공유합니다. 세팅하는 방법은 간단합니다. Gemfile파일 안에 해당 부분을 작성합니다.  https://github.com/minesafety-eng/minesafety-eng.github.com/blob/master/Gemfile  gem 'jekyll-admin', group: :jekyll_plugins  cmd창에서 해당 명령어 실행합니다.  # bundle install # jekyll serve   이제  http://localhost:4000/admin/ 으로 접근 가능하며 게시물을 쉽게 작성하고 수정할 수 있습니다.      Step 7: 도메인 연결  구매한 도메인이 있어 http://{깃헙id}.github.io/ 형식이 아닌 자신이 구매한 도메인으로 연결하는 방법을 공유하겠습니다. 우선 자신 Repository의 Settings로 접속합니다. ( https://github.com/{깃헙 id}/{Repository}/settings) 이제 중반 GitHub Pages 옵션 중 Custom domain부분에 자신이 구매한 Domain주소를 작성합니다.  이미지 중 Custom domain 옆 Learn more을 눌러보면  관련된 정보를 획득할 수 있습니다. 이 중  Managing a custom domain for your GitHub Pages site 내용 중  중반 ALIAS설정하는 방법이 나와있습니다.  해당 A 레코드를  도메인을 구매한 사이트에 세팅해줍니다. 필자는 가비아를 사용하여 해당과 같이 수정진행 하였습니다.     Step 8: MakerWidget 및 Disqus 세팅  필자 블로그 우측 하단에 떠있는 위젯과 댓글을 위한 Disqus세팅방법을 공유하겠습니다.   MakerWidget 세팅  https://makerwidget.com에서 회원 가입을 진행합니다. 이후 LINK LISTS , PROJECTS등 원하는 부분을 작성하고 SAVE합니다.   최종적으로 저장 후 EMBED WIDGET을 확인합니다.   해당 스크립트를 프로젝트 js에 적어주시면 바로 적용됩니다.   Disqus 세팅  게시물에 댓글을 달 수있게 기능을 제공하는 Disqus는 유로인 경우도 있지만 무료서비스 중 Non-Commercial(Under 5,000 total daily pageviews)로 선택한다면 무료로 사용 가능합니다. 우선  https://disqus.com/에서 회원가입을 진행합니다.       회원가입이 완료되셨다면  이제 _config.yml을 수정해 줍니다.  provider에  disqus를 추가해주고  shortname에  가입시 작성하였던 Website Name을 적어주시면 됩니다.   https://github.com/minesafety-eng/minesafety-eng.github.com/blob/master/_config.yml   # 댓글 관련 부분 comments:   provider               : \"disqus\" # false (default), \"disqus\", \"discourse\", \"facebook\", \"staticman\", \"staticman_v2\", \"utterances\", \"custom\"   disqus:     shortname            : minesafety-eng # https://help.disqus.com/customer/portal/articles/466208-what-s-a-shortname- \t\t      Step 9: 구글 검색 가능하게 하기  게시글에 대해 구글 검색이 가능하게 하고 싶다면 Google Search Console을 통해 등록을  진행해야 합니다.  좌측은 구매한 도메인이 있을때 사용하며 하나의 도메인 등록을 통해 모든 서브도메인을 통합 관리하는 방식입니다. 우측(URL prefix)은 일반적인 GitBlog일 때입니다. 우선 우측 URL prefix 방식을 통해 먼저 진행하겠습니다. URL에  http://minesafety-eng.github.io/ 통째로 적습니다.     이제 블로그 도메인에 대한 소유권 인증을 진행해야 합니다. 사이트에 소유권자만이 구글 검색에 대해 허가를 내줄 수 있기 때문입니다. 소유권 확인을 위한 html파일을 다운로드 한 후 index.html페이지 위치에 올린 후 push합니다. 정상적으로 push가 되었다면 이제 Verify 혹은 확인 버튼을 클릭하여 소유권 인증을 마무리합니다. 아직은 아무 정보가 없어 웹사이트 유입현황이나 정보를 취득하지 못합니다. 물론 검색도 되지 않습니다. 구글 검색 엔진이 웹사이트를 읽어가는 작업이 진행되어야 검색이 노출되는데 이를 크롤링이라 합니다. 정상적인 크롤링을 위해서는 sitemap.xml과 robots.txt이 필요합니다.   sitemap.xml  sitemap.xml은 웹사이트 내 모든 페이지의 목록을 나열한 파일로 책의 목차와 같은 역할   robots.txt 파일과는 달리 sitemap.xml 파일은 꼭 루트 디렉토리에 위치하지 않아도 된다.   robots.txt  검색 엔진 크롤러에서 사이트에 요청할 수 있거나 요청할 수 없는 페이지 설정하는 부분 및 제어하는 부분  검색 로봇들에게 웹사이트의 사이트맵이 어디 있는지 알려주는 역할  항상 root 폴더에 위치해 /robots.txt를 입력하면 확인 가능  sitemap.xml은 정해진 양식으로 제작되어야 하고, 이 양식은 대한민국 뿐 아니라 전 세계적으로 약속된 방식    sitemap.xml 생성  sitemap.xml을 수동으로 작성하기보단 jekyll-sitemap 플러그인 통해서 관리하는 방법을 알아보겠습니다. 우선 Gemfile에 하단부분을 적어줍니다.  https://github.com/minesafety-eng/minesafety-eng.github.com/blob/master/Gemfile  gem 'jekyll-sitemap'  이제 cmd창에서 bundle install 명령어를 통해 플러그인 설치를 진행하고 서버를 시작합니다.  # bundle install # jekyll serve  정상적으로 설치가 되었다면 아래와 같이 접근 가능합니다.   http://localhost:4000/sitemap.xml  플러그인이 자동으로 페이지에 있는 모든 정보를 가지고 와 sitemap을 만들어 줍니다.   robots.txt 생성  이제 index.html위치에 robots.txt파일을 생성하고 아래에 내용을 작성합니다. https://github.com/minesafety-eng/minesafety-eng.github.com/blob/master/robots.txt  User-agent: * Allow: /  Sitemap: https://minesafety-eng.github.io/sitemap.xml   모든 웹사이트 콘텐츠에 대한 모든 웹 클롤러의 접근을 차단  User-agent: *  Disallow: /   만약 구글 로봇만 차단시키고 싶다면 User-agent에 * 부분을 Googlebot으로 변경하여 설정  User-agent: Yeti  Disallow: /hello/   이렇게 설정하면 웹사이트의 모든 콘텐츠의 네이버 검색로봇의 크롤링을 허용하되, /hello/  디렉토리 안의 페이지에 대한 접근만 차단한다는 의미   Google에 sitemap.xml등록  Google Search Console페이지 메뉴 중 sitemaps에 들어가서 생성한 sitemap.xml을 제출합니다.     Please Note: sitemap까지 등록되었다면 검색 노출까지 일주일 정도 기간이 걸린다고 합니다.   이제 좌측 도메인 등록방법을 설명하겠습니다.  http를 제외한 도메인 주소를 작성합니다. 필자의 도메인 주소인 honbabzone.com을 적어준 후 TXT를 얻습니다.         해당 텍스트를 도메인 설정에 등록합니다.     10분정도 시간이 지난 후 도메인 소유권 확인을 누르면 도메인 인증이 됩니다.   이상으로 블로그를 처음 시작하시는 분들에게 도움이 되었길 바라며 GitBlog 시작하기에 대한 포스팅을 마치겠습니다. 감사합니다.  ","categories": ["Jekyll"],
        "tags": [],
        "url": "https://minesafety-eng.github.io//jekyll/start-gitHubBlog/",
        "teaser":null},{
        "title": "JVM( Java Virtual Machine )이란",
        "excerpt":"제임스 고슬링(James Gosling)이 개발한 JAVA 언어를 깊이 이해하기 위해서는 JVM( Java Virtual Machine )의 구조 파악(너무 깊지 않게)이 선행적으로 필요하다고 생각되어 이전 공부했던 내용을 다시 정리하겠습니다.   Step 1: JVM의 기본 구성  기본적으로 JAVA 프로그램이 사용자에 의해 실행되면 JVM은 운영체제로부터 필요한 메모리를 할당받아 JAVA 프로그램을 처리합니다. 1995년부터 1999년도 윈도우 프로그램 개발이 대세였던 시절 JAVA는 메모리 및 CPU를 지나치게 많이 사용한다는 단점 때문에 많이 사용되는 언어가 아니었습니다. C++언어가 주류를 이루었지만 1999년도부터 인터넷이 활성화되고 하드웨어의 큰 발전과 스마트폰의 등장은 JAVA 붐을 일으켰고 이제는 세계시장에서 점유율 1위라는 타이틀을 차지하고 있습니다. 이전에는 윈도우환경, 리눅스 또는 유닉스 환경에서 실행되는 프로그램 만들기 위해서는 각자의 환경에 따라 개발을 달리 해야 하는 문제가 있었습니다. 하지만 JAVA는 JVM을 통하여 실행되기 때문에 어떠한 운영체제에서도 동일한 형태로 실행시킬 수 있다는  장점이 있습니다.      JVM은 크게 Garbage collector, Execution Engine, Class Loader, Runtime Data Area 4가지 영역으로 나누어집니다. 이 중에서 개괄적으로 Garbage collector, Execution Engine, Class Loader에 대해 설명하고 메모리 구조를 파악하기 위해 Runtime Data Area에 대해 조금 더 정리하겠습니다. Garbage collector, Execution Engine, Class Loader는 차츰차츰 단독 포스트로 하여 기존 공부한 부분과 새롭게 알게 된 부분을 다시 정리하겠습니다.   좀 더 정확한 개념을 위한 설명    JVM  자바 바이트코드들을 OS에서 어떻게 실행할 지에 대한 표준 스펙이며 다양한 구현체가 존재합니다. JAVA라는 언어로 개발하기 때문에 OS에 독립적이란 의미지 JVM자체로는 OS마다 어떻게 실행되어야 하는지 정의된 것을 구현하기 때문에 OS에 종속적입니다.   좀 더 정확히는 JVM은 하나의 표준이자 스펙입니다. 이러한 JVM 표준을 가지고 특정 밴더( 오라클, 아마존 등등 )들이 JVM을 구현합니다.    JRE  JAVA어플리케이션을 실행하기 위한 최소 배포 단위로서 JVM과 필요 Library가 포함됩니다.( 실행이 목적이라 개발 관련 도구는  포함되지 않습니다.)   오라클은 자바 11부터 JDK만 제공하며 JRE를 따로 제공하지 않습니다.   JDK  JRE + 개발에 필요한 툴이 포함됩니다.   오라클은 자바 11부터 JDK만 제공하며 JRE를 따로 제공하지 않습니다.  소스코드를 작성할 때 사용하는 자바는 플랫폼 독립적입니다.   JAVA 유료화에 대한 잘못된 상식  JAVA언어가 유료화가 되는 것이 아니라 오라클에서 만든 JDK 11버전부터 상용으로 사용할 때 유료입니다. 즉 여러 JDK 중에서 오라클에서 만든 Oracle JDK11만이 유료입니다.  다른 Oracle  open JDK는 무료이며 아마존에서 만든 JDK, 다른 벤더들이 구현한 JDK는 무료입니다.   ① Garbage collector(GC)  잠시 후에 공부할 Runtime Data Area  중 Heap영역에 더 이상 사용하지 않고 자리만 차지하고 있는 객체들을 제거하는 역할을 합니다. 자동으로 실행되기 때문에 언제 정확히 언제 실행되는지 알기 어렵고 사용자가 임의로 GC를 발생시키는 것은 좋은 발상이 아니기에 JVM에 맡기는 것이 좋습니다. 기본적인 특징은 GC가 수행되는 동안 GC를 실행하는 쓰레드 외 모든 쓰레드가 일시정지 됩니다.   ② Class Loader  개발의 결과물로 우리는  .java파일을 생성합니다. 이러한 .java파일은 컴파일러(javac)에 의해 .class파일 즉 JAVA Byte Code(바이트코드) 로 컴파일되고, 이렇게 컴파일된 바이트코드들을 Class Loader가 운영체제에 의해 메모리를 할당 받은 Runtime Data Area으로 적재하는 역할을 합니다.   ③ Execution Engine  Class Loader에 의해 Runtime Data Area에 적제된 .class파일들을 하나의 명령단위로 읽어서 컴퓨터가 이해할 수 있는 기계어로 번역하고 명령을 실행합니다.  Interperter방식과  JIT(Just-In-Time) 방식이 존재하고 추후 포스트에 자세히 다루어 보겠습니다.   ④ Runtime Data Area  JVM메모리 영역으로 OS로부터 별도로 메모리 공간을 할당받고 JAVA 어플리케이션을 실행할 때 사용됩니다. Method Area, Heap Area, Stack Area, PC register, Native Method Stack 총 5가지로 구분됩니다.      Step 2: Runtime Data Area  ① Method Area(Static Area)  Method Area(Static Area) 는 java 어플리케이션이 실행되면 클래스 별로 클래스에서 필요한 패키지 클래스, 런타임 상수풀, 인터페이스, 상수, static변수, final 변수, 클래스 멤버 변수 등 필드데이터, 생성자를 포함한 모든 메서드 정보 등 한번 로드 된 후 메모리에 항상 상주하고 있는 영역입니다. 그래서 모든 스레드가 공유가능 합니다. 예를 들어 Math.abs(-10) 같이 Math 클래스의 메서드를 초기화 없이 바로 사용할 수 있는것은 해당 영역에 덕분입니다.   ② Heap Area  Heap Area은 메서드 안에서 사용되는 객체들을 위한 영역으로 new를 통해 생성된 객체, 배열, immutal 객체 등의 값이 저장됩니다. 해당 영역에서 생성된 객체들은 다음에 나올 JVM Stack Area의 변수나 다른 객체의 필드에서 참조 가능합니다. 때문에 해당 객체를 참조하지 않으면 더는 쓸모가 없어 Garbage Collector에 의해 객체가 Heap 영역에서 제거됩니다.   ③ Stack Area  Stack Area은 스레드마다 하나씩 존재하며 쓰레드가 시작될 때 할당됩니다. 내부에는 매소드에서 직접 사용할 지역 변수, 파라미터, 리턴 값, 참조 변수일 경우 주소 값 들이 저장됩니다. 만약 프로그램에서 매소드가 호출되면 매소드와 매소드 정보는 차곡차곡 Stack에 쌓이면서(PUSH) 내부 과정을 실행합니다. 매소드 호출이 종료되면 해당 매소드는 Stack Area에서 제거(POP) 됩니다.     ④ PC register  PC register은 Thread가 생성될 때마다 생성되는 영역으로 Program counter 즉 현재 쓰레드가 실행되는 부분의 주소와 해당 명령을 저장하고 있는 영역입니다. 이것을 이용해 다수의 쓰레드들이 명령의 흐름을 잃지 않고 함수가 순차적으로 실행됩니다.   ⑤ Native Method Stack  Native Method Stack은 자바 외 다른 언어로 작성된 네이티브 코드를 수행하기 위한 메모리 영역입니다. JAVA 이외의 다른 언어에서 제공되는 Method의 정보가 저장됩니다.   이제는 Runtime Data Area영역 중  Heap Area영역이 어떻게 구성되어 있는지 살펴보겠습니다.   Step 3: Heap Area   힙 영역은 Eden, Survivor1, Survivor2, Old 영역, Permanent영역( 생성된 객체들의 주소값이 저장되는 영역 )으로 나누어집니다. 힙을 이렇게 나눈 이유는 효율적인 GC를 위해서입니다. GC는 크게 Minor GC와 Major GC로 구분되는데 이를 살펴보겠습니다. 우선 new를 통해 객체가 생성되면 Eden영역에 생성됩니다. new를 통해 다양한 객체가 생성 중 만약 Eden 영역이 가득 차게 된다면 첫 GC가 일어납니다. Eden에서 참조되지 않은 객체를 제거하고 참조가 유지되는 객체를 S1 영역으로 이동시킵니다. 다시 new를 통한 객체가 생성중 또 Eden 영역이 가득 차게 되면 이번에는 S1 영역이 아닌 S2 영역으로 참조를 유지하고 있는 객체들을 이동시킵니다. 이와 더불어 S1 영역에 있는 객체 중 참조가 유지되고 있는 객체 또한 S2로 이동시키고 age를 +1 합니다. 이를 Minor GC라고 부릅니다. 이렇게 Eden -&gt; S1 -&gt; S2-&gt;S1…이 반복적으로 일어나게 되면서 오랫동안 살아남는 객체는 age가 지속해서 증가하게 되는데 어느 정도 age가 증가하여 오랫동안 살아남으면 이제는 Old 영역으로 객체를 옮기게 됩니다. Major GC는 Old 영역에 있는 모든 객체를 검사하고 참조되고 있는지 확인 후 참조되지 않은 객체들을 모아 한번에 제거하는 것을 말합니다. 이를 Full GC라고도 하며 Full GC는 GC를 제외한 모든 쓰레드가 중지되어야 합니다.   Step 4: 예제로 알아보기  지금까지 JVM의 메모리 구조에 대해 알아봤습니다. 그렇다면 좀 더 명확히 이해하기 위해 예제를 통해 Class 코드들이 어디에 위치하고 어떻게 동작하는지 알아보겠습니다.  // TEST 클래스 public class Test {     //클래스 필드     public static int ONE       = 1;     public static String TWO    = \"TWO\";     public static String FOUR;          // 상수     public static final int FIVE    = 10;      // 정적 블럭     static {         FOUR = \"안녕하세요\";     }          //인스턴스 필드     private int three;          public Test( int three ) {         this.three = three;     }          // 클래스 메서드     public static int sum( int a , int b ) {         return a + b;     }          //인스턴스 메서드     public int multiply( int a, int b ) {         return a*b;     }      public int getThree() {         return three;     } }    // main thread  public static void main(String args[]){         int one       = Test.ONE;         String two    = Test.TWO;         int one_sum_two = Test.sum(1, 2);                  Test test = new Test(3);         int three = test.getThree();         int two_multiply_three = test.multiply(2, 3);                  System.out.println(\"one : \" +one);         System.out.println(\"two : \" +two);         System.out.println(\"one_sum_two : \" +one_sum_two);         System.out.println(\"three : \" +three);         System.out.println(\"two_multiply_three : \" +two_multiply_three);         System.out.println(\"FOUR : \" +Test.FOUR);         System.out.println(\"FIVE : \" +Test.FIVE);  }   1 2 3 4 5 6 7 8 // 출력  one : 1 two : TWO one_sum_two : 3 three : 3 two_multiply_three : 6 FOUR : 안녕하세요 FIVE : 10   Class Loader에 의한 Test.class파일의 로드 과정     ① Main 메서드 안에서 int one       = Test.ONE;을 만났다!   첫째로 컴파일 시점이 아닌 runtime 시점에서 모든 과정은 시작됩니다. 직접 만든 java 어플리케이션을 실행하는 도중(main 메서드 실행 중) 위 Test.class파일을 사용하는 부분을 처음 만나는 순간 Class Loader에 의해 Test.class 파일이 Loading, Linking, Initialization 과정을 겪습니다.   Loading  BootStrap ClassLoader, Extension ClassLoader,  Application ClassLoader 3개의 클래스 로더를 통해 Test.class파일이 JVM안으로 로드됩니다. Class Loading을 요청받았을 때 BootStrap ClassLoader &gt;  Extension ClassLoader &gt; Application ClassLoader 순서로 우선권을 가지며 BootStrap ClassLoader에 없다면 Extension ClassLoader을 찾고 Extension ClassLoader에 없다면 최종적으로 Application ClassLoader에서 찾는다고 생각하시면 됩니다. Test.class파일은 Application ClassLoader가 찾아 Loading합니다.           BootStrap :  가장 최상위 ClassLoader로 java.lang.Object같은 핵심 시스템 Class를 로딩합니다.  $JAVA_HOME/jre/lib 위치에 있는 JAR 파일이 그 대상입니다. 위를 변경하기 위해서는 -Xbootclasspath옵션을 통해 변경 가능합니다.            Extension ClassLoader : $JAVA_HOME/jre/lib/ext에 위치한 JAR 파일을 로딩합니다. 사용자의 classpath를 수정하지 않고 다양한 보안 확장프로그램 같은 새로운 확장 프로그램을 로드할 수 있습니다.            Application ClassLoader : $CLASSPATH에 위치한 JAR 파일을 로딩합니다. 직접 만든 어플리케이션의 JAR파일의 classpath라고 보시면 됩니다.       Linking     Verify : 로드된 Test.class파일들의 에러를 확인합니다.   Prepare : Test.class파일들을 훝으면서  static키워드가 붙은 멤버들에 대해 메모리만 할당하고 기본값으로 세팅합니다. (아직 정확하게 값을 넣기 전입니다.) 즉 public static int ONE  = 0;으로 세팅합니다.   Resolve  : Test.class파일들을 훝으면서 지금은 없지만 symbolic reference( Test.TWO와 같이 객체 이름으로 참조하는 것)들을 Method Area에서 실제 주소값을 찾고 그 주소값으로 참조객체들을 세팅합니다.   Initialization  최종 단계로 모든 정적 변수는 원래 값으로 할당되고 정적 블록이 실행됩니다. public static int ONE = 1값으로  할당하고,  static 블록 내부 FOUR=”안녕하세요” 를 실행합니다. 이때 Method Area로 Test.class에 있는 모든 정보들이 Method Area안 독립적인 Test.class 영역으로 배치됩니다.       Field Information  Class 멤버변수의 이름 및 데이터 타입, 접근 제어자에 대한 정보를 저장   Method Information  Class 멤버메서드의 이름, 리턴타입, 매개변수,  접근제어자에 대한 정보   Type Infomation  Type의 속성이 Class인지 Interface인지여부 , 패키지명, Supper Class에 대한 정보   Constant Pool  class에서 사용된 상수가 저장되는 영역, Symbolic reference 객체도 여기에 저장된다.   Static Variable  static 변수들에 대한 정보들이 저장된다.   ② Main 메서드 안에서 Test test = new Test(3);을 만났다!   Method Area에서 객체정보를 읽어 Heap메모리 안에 독립적으로 생성합니다.       Info: 지금까지 이전에 공부했던 내용을 정리해보면서 내용을 다듬었습니다. 잘못된 부분은 댓글 남겨주시면 수정하겠습니다. 감사합니다.   참고자료   – https://dzone.com/articles/jvm-architecture-explained    ","categories": ["JAVA"],
        "tags": [],
        "url": "https://minesafety-eng.github.io//java/java-jvm/",
        "teaser":null},{
        "title": "Java에서 자주 보이는 Static이란 무엇일까?",
        "excerpt":"Step 1: Static Base  클래스 안에서 static 키워드가 붙는 경우는 2가지가 존재합니다.  하나는 변수 앞에 static 키워드가 붙는 케이스이며 이를  static 변수 혹은 정적 변수라고 합니다.  public static double pi = 3.14  다른 하나는 메서드 앞에 붙는 경우로 static 메서드 혹은 정적 메서드라고 합니다.  public static int plus ( int x , int y ){      return x + y;  }   Step 2: JVM 메모리 구조  static 키워드를 이해하기 위해서는 JAVA에 꼭 필요한 JVM의 메모리 구조 및 실행 단계에 대한 이해가 선행되어야 합니다.  JVM은 크게 Garbage collector, Execution Engine, Class Loader, Runtime Data Area 4가지 영역으로 나누어지고 이 중에서 static을 이해하는 데 필요한 Class Loader와 Runtime Data Area(메모리 영역)에 관해 이야기해보겠습니다.  우리가 코드를 작성한다면 확장자가 java인 *.java 파일들을 만들 것입니다. 해당 java 파일들은 Java 컴파일러(javac)에 의해 .class파일인 JAVA Byte Code로 컴파일됩니다.   이렇게 컴파일된 바이트 코드들은 Class Loader가 메모리가 할당된 Runtime Data Area으로 코드들을 적재시킵니다.   Please Note: 좀 더 JVM에 대해 자세한 부분은 JVM 포스트를 참고하시기 바랍니다.      Runtime Data Area은 Method Area, Heap Area, Stack Area, PC register, Native Method Stack 총 5가지로 구분됩니다.  이 중에서 static을 이해하는 데 필요한 3가지의 영역 중 하나인 Method Area(Static Area)은 초기 로드 필요한 정보들 즉 필요한 패키지 클래스, 인터페이스, 상수, static변수, final 변수, 클래스 멤버 변수 등 로드된 후 메모리에 항상 상주하고 있는 영역입니다.  Stack Area는 클래스 안 메서드 실행 시 해당 영역이 할당되며 메서드에서 직접 사용할 지역 변수, 파라미터, 리턴 값, 참조 변수일 경우 주소 값들이 저장됩니다.  Heap Area은 메서드 안에서 사용되는 객체들을 위한 영역으로 new를 통해 생성된 객체, 배열, immutal 객체 등의 메모리와 값이 저장됩니다.   Step 3: Static과 메모리 구조  클래스 로더가 .class파일을 탐색 중static 키워드를 보는 순간 객체가 생성되지 않아도 항상 메모리를 할당해야 하는 멤버로 보고 Method Area(Static Area)에 메모리를 할당합니다. 그래서 static 키워드가 붙은 멤버들은 객체(인스턴스)에 소속된 변수가 아니라 클래스에 소속된 변수이기 때문에 클래스 변수 혹은 클래스 메서드라고도 부릅니다. new를 통해 객체를 생성하면 각 인스턴스는 서로 독립적이지만 이러한 특징 그래서 static 키워드가 붙은 멤버들은 모든 객체가 메모리 영역을 공유하기에 공통으로 같은 영역을 바라보기에 아래와 같은 코드가 가능합니다.  public class Counter {     public static int count = 0;     Counter() {         this.count++;         System.out.println(this.count);     }     public static void main(String[] args) {         Counter c1 = new Counter();         Counter c2 = new Counter();     } }   1 2 3 1 2 출력    같은 이유로 static 메서드 안에서는 사용할 변수들은 메모리에 올라가는 순서 때문에 아래와 같은 코드는 불가능합니다. (스태틱 메서드 안에서는 인스턴스 변수 접근이 불가능합니다)  public class Counter {     public int count = 0;     Counter() {         this.count++;     }     public static int getCount() {         return count; // 에러 발생     }     public static void main(String[] args) {         Counter c1 = new Counter();         Counter c2 = new Counter(); \tSystem.out.println(Counter.getCount());     } }  static키워드를 만난 순간 메모리에 적제시켜야 하는데 count 변수에 대해 선언 및 메모리가 할당되어 있지 않아 에러가 발생합니다.  이를 해결하기 위해서는 count변수를 static변수로 만든다면 메모리 로드 시점에 count변수에 대한 선언이 존재하여 에러가 발생하지 않습니다.  public class Counter {     public static int count = 0;     Counter() {         this.count++;     }     public static int getCount() {         return count;     }     public static void main(String[] args) {         Counter c1 = new Counter();         Counter c2 = new Counter(); \tSystem.out.println(Counter.getCount());     } }  Step 4: Static 이슈  이러한 static의 특징들 때문에 메서드의 호출 시간이 짧아진다고 무분별한 static의 사용은 java에서 지양됩니다.  첫째로 static 변수는 글로벌 변수에 가까우므로 글로벌 변수는 인스턴스 변수보다 테스트가 까다로워집니다.  둘째 static 변수는 객체지향 프로그램의 원칙인 각 객체의 데이터들이 캡슐화되어야 한다는 원칙에 어긋나며 static 변수를 공유한 순간 서로에 영향을 주게 되어 어떤 사이드 이펙트가 발생할지 모른다고 생각됩니다.  또한 오버라이딩을 할 수 없으므로 코드의 재사용성이 떨어질 뿐만 아니라 프로그램이 종료되기 전에 항상 메모리에 상주하고 있어 자주 사용하지 않는 매서드가 누적된다면 GC에 수거되지 못하므로 오히려 메모리 낭비가 발생합니다.  이러한 이유로 단순히 빠르다는 이유로 static 메서드 및 변수를 사용을 지양해야 하며 여러 개의 인스턴스를 만드는 것을 피하고 싶다면 스레드 안정성을 가지는 싱글톤 패턴을 이용하여 클래스를 설계하는 것이 좋습니다. 그렇다면 어떤 경우에 static을 사용하는 것이 좋을까요? 자주 사용하는 객체 + 만드는데 오래 걸리고 메모리를 많이 사용하는 객체입니다. 예를 들어 아래와 같은 코드를 봅시다.  public class SpellChecker {     public boolean hasRomanNumeral(String inputText) {          return inputText.matches(\"^(?=[MDCLXVI])M*D?C{0,4}L?X{0,4}V?I{0,4}$\");       } }  코드만 보면 큰 이슈가 없는 로마자를 확인하는 메서드입니다. 단 matches 매서드의 내부 로직을 확인해보면 new Pattern(regex, 0); 부분이 있는데 이 패턴 객체를 컴파일하는 부분이 있는데 Pattern 객체는 무거운 객체입니다. 때문에 matches 메서드를 호출할 때마다 Pattern 객체를 만드는 부분을 static final객체를 통하여 효율적으로 변경할 수 있습니다.  public class SpellChecker {          private static final Pattern ROMAN = Pattern.compile( \"^(?=[MDCLXVI])M*D?C{0,4}L?X{0,4}V?I{0,4}$\" );          public boolean hasRomanNumeral(String inputText) {          return ROMAN.matcher(inputText).matches();      } }  비용이 많이 드는 Pattern 부분을 stataic final을 통해 한 번만 초기화 후 가져다 쓰는 로직으로 변경하여 메모리 낭비를 줄이고 속도를 증가시켰습니다. 물론 해당 코드의 이슈는 SpellChecker를 사용하지 않아도 ROMAN가 메모리에 항상 상주하는 것이 문제기 때문에 lazily initializing이라는 게으른 초기화 방법을 통해 제거할 수 있지만, 지연 초기화는 측정 가능한 성능 개선 없이 구현을 복잡하게 한다고 하여 추천하지 않는다고 합니다.   참고자료     – 이펙티브 자바  – https://www.youtube.com/watch?v=0yUxPUXS1pM&amp;t=404s  (백기선 강사님)   ","categories": ["JAVA"],
        "tags": [],
        "url": "https://minesafety-eng.github.io//java/java-static/",
        "teaser":null},{
        "title": "Java Enum이란",
        "excerpt":"Step 1: Enumeration의 이해와 정리  데이터 중에서는 요일 ( 월, 화, 수, 목, 금, 토, 일 ), 계절( 봄, 여름, 가을, 겨울) 등과 같이 몇 가지 한정된 값을 갖는 경우가 흔히 있습니다.  요일, 계절과 같이 한정된 데이터만을 가지는 타입을 Enumeration Type이라고 하며 열거타입에 들어가는 값( 월, 화 ,수 등 )들을 열거 상수( Enumeration constant)라고 합니다.  JAVA는 JAVA 1.5부터 이러한 열거형 타입들을 사용할 수 있게 되었으며 enum 데이터 타입이라고 표시됩니다.  관례로 열거타입을 선언하기 위해서는 JAVA Class 명처럼 열거타입의 이름을 정하고 타입이름으로 첫 글자 대문자로 하여 .java 파일을 생성합니다.  JAVA 파일 안에서 class대신 enum을 적어줍니다.  열거상수를 적을 때는 관례로 대문자로 적습니다. 만약 열거상수가 2개의 단어로 연결되어 있을 때는 _로 연결하는 것이 관례입니다.  Week.java  public enum Week {     MONDAY, TUSEDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY }    Step 2: Enum과 메모리 구조  JAVA에서 열거 상수는 상수 각각을 내부적으로 public static final 필드이면서 객체로 제공되도록 합니다.  static이 붙어있기 때문에 각각의 상수는 클래스변수로 클래스로더가 로드 시점에 JVM Method영역에 해당 클래스 변수들을 항상 상주시켜 프로그램이 종료되기 전에는 언제든지 가져다 쓸 수 있는 주소공간을 확보합니다.      Please Note: Emum을  호출하기 전에는 단순 공간만 확보합니다.  좀 더 JVM에 대해 자세한 부분은 JVM 포스트를 참고하시기 바랍니다.   Step 3: Enum과 메모리 초기화  이제는 사용 부를 살펴보겠습니다. 사용 부에서는 클래스의 인스턴스를 생성하는 것과 비슷하지만, new가 없는 형태입니다.  Week today = Week.MONDAY;  어떤 클래스에서든 해당 로직을 만나면  Heap영역에 Week 객체는 MONDAY부터 SUNDAY까지 각각 java.lang.Enum클래스를 상속받는 고유의 객체가 만들어지고 Method 영역의 열거상수들은 해당 Heap영역에 생성된 객체를 바라봅니다. 즉 로직을 만나는 순간 이전에 Method에 할당되었던 메모리에 Heap영영에 생긴 객체들이 할당됩니다.       today변수는 JVM Stack영역에서 사용하므로 stack영역의 today는 Method 영역에 있는 MONDAY의 객체의 주소 값을 복사하므로 today와 Week.MONDAY는 Heap에 생성된 같은 객체를 바라봅니다.          이러한 이유로 today == Week.SUNDAY 로직이 같은 객체를 반환하므로 true가 성립됩니다. 같은 이유로 아래 코드가 true가 나와도 이해가 됩니다.  Week thisWeek = Week.SUNDAY; Week nextWeek = Week.SUNDAY; thisWeek == nextWeek // true   Step 4: Enum의 응용  열거상수 즉 열거객체들은 java.lang.Enum클래스를 상속받기 떄문에 name(), ordinal(), compareTo(), valueOf(String name), values() 메서드를 사용할 수 있습니다.  관례적으로 열거 타입을 선언하기 위해서는 열거 타입의 이름(첫 글자 대문자)을 정하고 타입이름으로 .java 파일을 생성하지만, 특정 클래스에서만 필요한 열거 타입이라면 아래와 같이 사용 가능합니다.  public class Shoes {     public String name;     public int size;     public enum Type {         WALKING, RUNNING, TRACKING, HIKING        } }   enum은 class처럼 생성자를 가질 수 있지만 고정된 상수의 집합임으로 런타임이 아닌 컴파일 타임에 모든 값을 가지고 있어야 하기에 private로 선언되어야 오류가 발생하지 않습니다.  각각의 열거 상수 객체가 Heap에서 각각 생성됨으로 아래와 같은 결과가 발생합니다.  public enum Color {     RED, GREEN, BLUE;      private Color() {          System.out.println(\"Constructor called for : \" + this.toString());      }  }  Color color = Color.BLUE;   1 2 3 4 // 출력 Constructor called for : RED Constructor called for : GREEN Constructor called for : BLUE   Enum 일반 메서드  enum은 다른 추상 메서드가 아닌 일반 메서드를 가질 수 있습니다.  public enum Color {     RED, GREEN, BLUE;      public void colorInfo() {          System.out.println(\"Universal Color\");      } }  Color.BLUE.colorInfo();   1 2 // 출력 Universal Color;   Enum 추가 속성과 생성자  열거형 상수는 추가 속성을 부여할 수 있으며 추가 속성이 여러 개가 있을 시 생성자에 순서대로 각각의 타입으로 넣을 수 있습니다.   public enum Color {      RED(\"빨강\",100), GREEN(\"초록\",10), BLUE(\"파랑\",30);           private String koreName;     private int pay;      // 빨강, 100 순서대로 할당된다.     private Color(String koreName, int pay){          this.koreName = koreName;         this.pay      = pay;     }       public void colorInfo(){          System.out.println(koreName +\"의 비용은 \" + pay +\"입니다.\");      }  }  Color.BLUE.colorInfo();   1 2 // 출력  파랑의 비용은 30입니다.   Enum 메서드 재정의  abstract 메서드를 통해 열거형 상수안에 각 상수별로 특정 메서드를 재정의 하도록 할 수 있습니다.  public enum Color {     RED(\"빨강\",100) {         @Override         public int calc(int a, int b) {             return a+b;         }     }, GREEN(\"초록\",10) {         @Override         public int calc(int a, int b) {             return a-b;         }     }, BLUE(\"파랑\",30) {         @Override         public int calc(int a, int b) {             return a*b;         }     };           private String koreName;     private int pay;     private Color(String koreName, int pay){          this.koreName = koreName;         this.pay      = pay;     }       public void colorInfo(){          System.out.println(koreName +\"의 비용은 \" + pay +\"입니다.\");      }           public abstract int calc( int a, int b ); }  System.out.println(Color.BLUE.calc(5,10));     1 2 // 출력  50   중첩 Enum  만약 enum상수끼리 공유하는 코드를 만들고 싶다면 중첩 Enum을 만들어 응용할 수 있습니다.  public enum Color {     RED(\"빨강\",100,CheckPay.RED ), GREEN(\"초록\",30,CheckPay.RED), BLUE(\"파랑\",49,CheckPay.BLUE);          private String koreName;     private int pay;     private CheckPay checkPay;     private Color(String koreName, int pay, CheckPay checkPay ){          this.koreName = koreName;         this.pay      = pay;         this.checkPay = checkPay;     }            public int calc() {         return this.checkPay.calc(pay);     };          private enum CheckPay{         RED {             @Override             public int calc(int pay) {                 return pay*100;             }         },BLUE{             @Override             public int calc(int pay) {                 return pay*50;             }         };                  public abstract int calc( int pay );     } }  System.out.println(Color.BLUE.calc());    1 2 // 출력  2450   참고자료     – 이것이 자바다    – https://wedul.site/285  – http://woowabros.github.io/tools/2017/07/10/java-enum-uses.html  – https://velog.io/@pop8682/Enum-27k067ns4a  – https://www.opentutorials.org/module/1226/8025   ","categories": ["JAVA"],
        "tags": [],
        "url": "https://minesafety-eng.github.io//java/java-enum/",
        "teaser":null},{
        "title": "JAVA 용어에 대한 정리( 인스턴스 멤버, 정적 멤버 등 )",
        "excerpt":"Step 1: 인스턴스 멤버와 클래스 멤버  인스턴스 멤버와 클래스 멤버라는 용어를 책에서 읽더라도 부끄럽게도 Class안 필드와 메서려니 하고 디테일에 집중하지 않았습니다. 좀 더  개념적으로 정확한 의미에 대해  가볍게 다시 한 번 정리하고 넘어가겠습니다.   ~ 멤버  멤버는 영어로 Member  = 해석하면 구성원이라고 합니다.    우리가 사용하는 멤버의 종류는 크게 2가지로 구분합니다.    ① 필드  ( Field )  ② 메서드 ( Method)    인스턴스( Instance ) 멤버  인스턴스 메버란 New를 통해 객체를 생성한 후 사용할 수 있는 필드와 메서드를 말합니다.   인스턴스 멤버에서도 객체 내부의 인스턴스 멤버에 접근하려면 this를 통해 가능합니다.   public class Test {     //인스턴스 필드     private int three;          public Test( int three ) {     //this를 통해 인스턴스 멤버에 접근할 수 있다. this.three는 위의 인스턴스 필드를 가르킵니다.         this.three = three;     }          //인스턴스 메서드     public int multiply( int a, int b ) {         return a*b;     } }    클래스 멤버 = 정적 멤버 = Static 멤버  객체를 생성하지 않고도 사용할 수 있는 필드와 메서드를 말합니다.   public class Test {     //클래스 필드     public static int ONE       = 1;     public static String TWO    = \"TWO\";     public static String FOUR;          // 클래스 메서드     public static int sum( int a , int b ) {         return a + b;     }      }   Step 2: Final  final 필드  final 필드는 한번 초기화되면 더는 수정할 수 없는 필드를 말합니다. 만약 외부에서 주입해주는 값으로 초기화해주고 싶다면 생성자를 이용하면 됩니다. 다만 생성자에서도 초기화해주지 않는다면 컴파일 에러가 납니다.   public class Test {     private final int one = 10;     private final int two;          public Test( int two ) {         this.two = two;     } }   static final = 상수  위에서 살펴 본 것처럼 final 필드는 한번 초기화되면 더는 값을 수정할 수 없다고 하였습니다. 그렇다면 final 필드를 상수라고 하면 되지 않을까요? 그렇지 않습니다. 상수란 불변의 값을 말합니다. 위의 final 변수 중 TWO는 생성자로 인해 객체마다 원하는 값으로 세팅할 수 있기 때문에 공용성을 띄지 못합니다. 때문에 모든 클래스가 공유하고 더는 바꿀 수 없는 값인 static final을 상수라고 부릅니다. 상수는 대문자로 쓰는것이 관례입니다. 혼합된 이름이라면 언더바를 사용합니다. 꼭 선언시 초기화 해주어야 하지마 복잡한 값이라면 정적 블록에서 초기화할 수 있습니다.   public class Test {     private static final String MY_NAME = \"김석진\"; \t\tprivate static final int TWO;          static {         TWO = 100;     } }   final 메서드  최종적인 메서드로 더이상 오버라이딩(Overriding) 할 수 없는 메서드를 말합니다. 즉 부모 메서드에 final이 붙어있다면 더이상 자식클래스에서 재정의 할 수 없습니다.   public class Test {     public final int sum( int a, int b ) {         return a + b;     } }   final 클래스  최종적인 클래스로 더이상 상속할 수 없는 클래스가 됩니다.   public final class Test {     public int sum( int a, int b ) {         return a + b;     } }   참고자료     – 이것이 자바다 (한빛 미디어)   ","categories": ["JAVA"],
        "tags": [],
        "url": "https://minesafety-eng.github.io//java/java-term/",
        "teaser":null},{
        "title": "JAVA 어노테이션에 대한 정리",
        "excerpt":"Step 1: 자바에서 어노테이션(Annotation)이란?  Anonotation은 메타데이터(metadata) 즉 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것인지를 알려주는 정보입니다. 주로 컴파일러에게 코드 문법 에러를 검사하도록 정보를 제공하거나 코드를 자동으로 생성할 수 있도록 정보를 제공, 런타임 시 특정 기능을 실행하도록 정보를 제공합니다. 사용 방식은 @ + 어노테이션 명으로 사용할 수 있습니다. 그렇다면 이제 어노테이션을 어떻게 정의하고 적용하는지 알아보겠습니다.   Step 2: 어노테이션 타입 정의  어노테이션의 타입을 정의하는 방법은@interface를 사용하여 정의합니다. public @interface {어노테이션 이름}이 기본 정의 방법입니다.   public @interface myanotation {  }  어노테이션은 엘리멘트( Element )라는 것을 멤버로 가질 수 있습니다. Element는 타입과 이름으로 구성되며 디폴트값을 가질 수 있습니다. 엘리먼트의 이름 뒤에는 메서드를 작성하는 것처럼 뒤에 ()를 꼭 붙여야 합니다.   public @interface myanotation {     //Element들     String myname();     int myage(); }  이렇게 정의한 어노테이션은 @myanotation(myName = “김석진” , myAge = 33 ) 혹은 @myanotation(myName = “김석진” , myAge = 33, myWeight = 74 ) 처럼 사용할 수 있습니다. 디폴트 값이 없는 경우에는 반드시 기술해야 하며 있는 경우는 옵션입니다. 기본 엘리멘트는 value이며 해당 값은 @어노테이션(값)으로 바로 사용 가능합니다.   public @interface myanotation {     String value(); }   // 사용 부 예시 @myanotation(\"test\")   Step 3: 어노테이션 적용 대상  기본적으로 어노테이션을 적용할 수 있는 범위는 미리 정의되어 있습니다. java.lang.annotation.ElementType에 열거 상수로 아래와 같은 값들이 있습니다.  TYPE : 클래스, 인터페이스, 열거 타입에 적용합니다. ANNOTATION_TYPE : 어노테이션에 적용합니다. FIELD : 필드에 적용합니다.  CONSTRUCTOR: 생성자에 적용합니다.  METHOD: 메서드에 적용합니다. LOCAL_VARIABLE: 로컬 변수에 사용합니다. PACKAGE: 패키지에 사용합니다.  어노테이션이 적용될 대상을 지정할 때 @Target 어노테이션을 사용합니다. @Target의 기본 엘리멘트( value() )는 ElementType의 열거상수를 배열을 값으로 가질 수 있습니다. 사용법은 아래와 같습니다. 예를 들어 myanotation은 필드와 메서드에 사용할 수 있는 어노테이션이라고 적용 대상을 한정한다면 아래와 같습니다.   @Target(value = { ElementType.FIELD , ElementType.METHOD }) public @interface myanotation {     String value(); }   Step 4: 어노테이션 유지정책  어노테이션 정의 시 한 가지 더 추가해야 합니다. 사용 용도에 따라 해당 어노테이션을 어디까지 유지할 것인지 지정하는 것입니다. 소스상에만 유지할 것인지 » 컴파일된 클래스까지 유지할 것인지 » 런타임 시에도 유지할 것인지 정해야 합니다. 해당 정책들은 아래와 같으며 java.lang.annotation.RetentionPolicy 열거 상수로 다음과 같이 정의되어 있습니다.   SOURCE : 소스상에서만 어노테이션을 유지하고 .class파일로 변경된 후에는 흔적이 남아 있지 않을 경우입니다. 주로 소스 코드를 분석할 때 사용되는 범위입니다.  CLASS : 바이트 코드에도 어노테이션 정보를 유지하는 것입니다. 추후 다루겠지만 리플렉션을 이용해서 어노테이션 정보를 얻을 수 없습니다.  RUNTIME : 리플렉션을 이용해서 런타임시에 어노테이션 정보를 얻을 수 있습니다.   리플렉션(Reflecion)이란 간단히 말해 Runtime시에 클래스의 메타 정보를 얻는 기능을 말합니다. 예를 들어 클래스가 가지고 있는 필드가 무엇인지, 어떤 메서드를 가졌는지 등 클래스에 대한 정보를 알아내는 것을 리플랙션이라고 합니다. 유지 정책을 정할 때는 @Retention어노테이션을 사용합니다. 기본 value()는 RetentionPolicy 열거 타입을 지정하면 됩니다. 위 값 중 하나를 지정하면 됩니다.   @Target({ ElementType.FIELD , ElementType.METHOD }) @Retention(RetentionPolicy.CLASS) public @interface Myanotation {     String value(); }    Step 5: Runtime 시 어노테이션 정보 사용하기  테이션 자체는 아무런 동작을 하지 않는 단순한 표식일 뿐이지만 리플랙션을 통해 런타임 시 엘리먼트 값을 이용해 특정 작업을 수행할 수 있습니다. 우선 클래스에 적용된 어노테이션 정보를 얻으려면 java.lang.Class를 이용하면 되지만 Class내부 필드와 생성자, 메서드의 적용된 어노테이션의 정보를 얻으려면 java.lang.reflect 패키지의 Field, Constructor, Method 타입의 배열을 얻어야 합니다.   getFields() :  필드 정보를 Field배열인 Field[]로 리턴한다. getConstructors() :  생성자 정보를 Constructor배열인 Constructor[]로 리턴한다.  getDeclaredMethods() : 메서드 정보를 Method배열인 Method[]로 리턴한다.   이후 Field, Constructor, Method 객체가 가지고 있는 다음 메서드를 통해 적용된 어노테이션 정보를 얻을 수 있습니다.   isAnnotationPresent( Class&lt;? extends Anotation&gt; annotationClass ) : 지정한 어노테이션이 적용되었는지 여부를 boolean타입으로 리턴합니다. Class에서 호출했을 때 상위 클래스에 적용된 경우도 true를 리턴합니다. getAnnotation( Class&lt;T&gt; annotationClass ) : 지정한 어노테이션이 적용되어 있으면 해당 어노테이션을 리턴하고 없을 시 null을 리턴합니다. 마찬가지로 상위 클래스에 적용되어도 같습니다. getAnnotations() : 적용된 모든 어노테이션을 Annotation[] 배열로 받습니다. 상위클래스도 포함합니다.  getDelaredAnnotations() : 상위 클래스를 제외한 직접 적용된 어노테이션 배열을 리턴합니다.   이제 Test 클래스에서 @Myannoation이 붙은 매서드를 찾아 절취선으로 구분하고 해당 메서드를 실행하는 코드를 예제를 진행해보겠습니다. method.invoke( new Test() )는 특정 객체를 생성하고 생성된 객체의 메서드를 호출하는 코드입니다.   @Target({ ElementType.METHOD }) @Retention(RetentionPolicy.RUNTIME) public @interface Myanotation {     String value() default \"-\";     int number() default 15; }   public class Test {     @Myanotation     public void testAnnotation() {         System.out.println(\"절취선 어노테이션을 테스트 합니다.\");     }          @Myanotation(value = \"*\")     public void testAnnotation2() {         System.out.println(\"**를 구분자로 가지는 어노테이션을 추적합니다.\");     } }   public static void main(String args[]){         Method[] declMethods = Test.class.getDeclaredMethods();         for (Method method : declMethods) {             if( method.isAnnotationPresent( Myanotation.class ) ) {                 System.out.println(\"[\" + method.getName() + \"]\");                 Myanotation settingMy = method.getAnnotation( Myanotation.class );                 for (int index = 0; index &lt; settingMy.number(); index++) {                     System.out.print(settingMy.value());                 }                 System.out.println();                                  try {                     method.invoke( new Test() );                 } catch (Exception e) {                 }                 for (int index = 0; index &lt; settingMy.number(); index++) {                     System.out.print(settingMy.value());                 }                 System.out.println();                 System.out.println();             }         } }    1 2 3 4 5 6 7 8 9 // 출력 [testAnnotation2] *************** **를 구분자로 가지는 어노테이션을 추적합니다. *************** [testAnnotation] --------------- 절취선 어노테이션을 테스트 합니다. ---------------   참고자료    – 이것이 자바다 (한빛 미디어)   ","categories": ["JAVA"],
        "tags": [],
        "url": "https://minesafety-eng.github.io//java/java-anontation/",
        "teaser":null},{
        "title": "JAVA 인터페이스에 대한 정리",
        "excerpt":"Step 1: 자바에서 인터페이스(Interface)란?  자바에서 인터페이스란 하나의 설계도입니다. 즉 인터페이스라는 껍데기를 만들어 놓고 어떤 클래스든 해당 인터페이스를 구현하려면 껍데기가 가지고 있는 메서드를 Override해야 완성이됩니다. 개발 코드와 구현 객체와의 중간 다리를 하는 인터페이스의 장점은 사용자로서는 개발 로직을 모르더라도 인터페이스의 정의된 메서드만 호출하여 사용하면 되고, 개발자로서 인터페이스의 정의된 메서드만 구현하면 되기 때문에 개발코드와 객체가 서로 통신하는 접점 역할을 합니다. 중간 다리로서 인터페이스는 인터페이스를 구현한 클래스를 바꾸기만 하면 되기 때문에 사용자는 원하는 객체를 쉽게 교체할 수 있고 로직을 변경하지 않아도 됩니다.   // 인터페이스  public interface MakePizza {     public abstract void makePizza(); }  // 구현 클래스 1 public class MakePepperoniPizza implements MakePizza {     @Override     public void makePizza() {         System.out.println(\"페페로니 피자를 만듭니다.\");     } }  // 구현 클래스 2 public class MakeMacaroniPizza implements MakePizza {     @Override     public void makePizza() {         System.out.println(\"마카로니 피자를 만듭니다.\");     } }  // 사용자 - 마카로니 피자가 먹고 싶은 경우  public static void main(String args[]){ \tMakePizza pizza = new MakeMacaroniPizza(); \tSystem.out.println(\"배고픈데 오늘은...\");     pizza.makePizza(); }   // 사용자 - 나중에 페페로니 피자가 먹고 싶은 경우  public static void main(String args[]){ \tMakePizza pizza = new MakePepperoniPizza(); \tSystem.out.println(\"배고픈데 오늘은...\");     pizza.makePizza(); }   Step 2: 인터페이스 선언  일반 클래스는 필드와 메서드를 구성 멤버로 가지는 데 비해, 인터페이스는 상수(static final)와 추상 메서드만을 구성 멤버로 가집니다. JAVA 7 이전까지는 인터페이스는 실행 블록이 없는 추상 메서드로만 선언이 가능했지만, JAVA 8부터 디폴트 메서드와 정적 메서드 선언이 가능합니다. 인터페이스 내부는 상수 필드와 추상 메서드만을 가질 수 있기에 상수를 의미하는 public static final이 필드 앞에 생략하여도 컴파일 과정에서 자동으로 해당 키워드를 삽입합니다. 마찬가지로 추상 메서드 또한 public abstract를 생략하더라도 자동으로 삽입됩니다.   public interface MakePizza {     public static final int CHECK_DEGREE = 400;     String BASE = \"핵 맛있는 피자\";          public abstract void makePizza();     void makeBestPizza(); }    디폴트 메서드   디폴트 메서드는 자바 8에서 새롭게 추가된 멤버로 일반 클래스의 메서드와 작성 방식은 같지만, 앞에 default키워드를 적어줍니다. 기본이 public이라 public을 생략하면 자동으로 붙여줍니다.  public interface MakePizza {     public static final int CHECK_DEGREE = 400;     String BASE = \"핵 맛있는 피자\";          public abstract void makePizza();     void makeBestPizza(); \t\t     // 디폴트 메서드     public default void isBestPizza( String name ) {         System.out.println( name + \"이 가장 맛있는 피자입니다.\");     }          default void isWorstPizza( String name ) {         System.out.println( name + \"이 가장 맛없는 피자입니다.\");     } }   디폴트 메서드는 인터페이스가 로직을 가지고 있지만 실제로는 인터페이스를 구현한 모든 객체에 기본적으로 들어가는 메서드라고 생각하면 됩니다. 또한, 구현하는 측에서 재정의해서 사용할 수 있습니다.   정적 메서드  정적 메서드는 디폴트 메서드와 마찬가지로 새롭게 추가된 멤버입니다. 항상 public하기 때문에 생략하여도 자동으로 삽입됩니다.   public interface MakePizza {     public static final int CHECK_DEGREE = 400;     String BASE = \"핵 맛있는 피자\";     \t // 정적 메서드     static void sayHack() {         System.out.println(BASE);     } }   Step 3: 익명 구현 객체  일반적으로 인터페이스는 구현 클래스를 만들어 사용하는 것이 일반적이지만 만약 일회성이라면 굳이 새로운 소스로 만들지 않고도 구현 객체를 만드는 방법이 있습니다. 다만 기억해야 할 것은 하나의 실행문을 작성 후 세미콜론을 빼먹으면 안 됩니다.   MakePizza pizza = new MakePizza() { \t@Override \tpublic void makePizza() { \t\tSystem.out.println(\"오늘은 막피자를 만들자!\"); \t} \t \t@Override \tpublic void makeBestPizza() { \t\tSystem.out.println(\"기분에 따라 달라~\"); \t} };  디버깅할 때 클래스명$1.css처럼 $1과 같은 표시는 이런 클래스 안에 익명 구현 객체를 표현한 것입니다.   Step 4: 중첩 클래스와 중첩 인터페이스  객체지향은 클래스 사이 긴밀한 관계를 가지고 있지만 어떤 클래스는 특정 클래스와 관계를 맺는 경우가 있습니다. 클래스가 여러 클래스와 소통하면 독립적인 파일로 존재하면 되지만 그럴 필요 없는 경우 클래스 내부에 클래스를 선언하는 방법이 있습니다. 이를 중첩 클래스 ( Nested Class )라 합니다. 중첩 인터페이스 또한 클래스 내부에 선언된 인터페이스를 말합니다.   public class TestClass {     // 중첩 클래스      class NestedClass {              }          // 중첩 인터페이스     interface NestedInterface {              } }   중첩 클래스  중첩 클래스는 내부에 선언된 위치에 따라 두 가지로 분류됩니다. 하나는 클래스의 멤버로서 선언되는 중첩 클래스를 멤버 클래스라고 하고, 매소드 내부에서 선언된 중첩 클래스를 로컬 클래스라고 합니다. 당연히 멤버 클래스는 객체가 살아있으면 언제든 재사용할 수 있지만 로컬 클래스는 메소드가 살아있는 순간에만 사용 가능합니다.  멤버 클래스는 세부적으로 인스턴스 멤버 클래스( 객체를 생성해야지만 접근 가능 ), 정적 멤버 클래스 ( A 클래스로 바로 접근 가능 )로 나누어집니다.   public class TestClass {     // 인스턴스 멤버 클래스      class NestedClass {              }          // 정적 멤버 클래스      static class StaticNestedClass {              }          // 로컬 클래스     public void testMethod() {         class NestedClass {                      }     }          // 중첩 인터페이스     interface NestedInterface {              } }    멤버 클래스도 하나의 클래스이기 때문에 바깥클래스 $ 멤버클래스 .class로 바이트코드가 별도로 생성됩니다. 로컬 클래스일 경우 바깥클래스 $1 로컬클래스.class로 파일이 생성됩니다.   인스턴스 멤버 클래스  인스턴스 멤버 클래스 내부 멤버는 인스턴스 필드와 메소드만 선언 가능합니다. 즉 static키워드가 붙은 정적 필드와 메소드는 선언 불가능합니다. 객체를 생성하기 위해서는 바깥 클래스를 생성 후 인스턴트 멤버 클래스를 생성해야 합니다.  public class TestClass {     // 인스턴스 멤버 클래스      class NestedClass {         private int temp;                 public NestedClass(int temp) {             this.temp = temp;         }                  public int getTemp() {             return temp;         }     } }  public static void main(String args[]){ \tTestClass testClass = new TestClass(); \tTestClass.NestedClass nestedClass = testClass.new NestedClass(100);  \tSystem.out.println(\"중첩 클래스 테스트  temp값: \" + nestedClass.getTemp()); }    1 2 //결과  중첩 클래스 테스트 temp값: 100   정적 멤버 클래스  정적 멤버 클래스는 인스턴스 멤버 클래스와 다르게 모든 필드와 메서드를 멤버로 가질 수 있습니다. 선언과 사용은 아래와 같습니다.  public class TestClass {     // 정적 멤버 클래스      static class StaticNestedClass {         private int temp;         private static int staticvalue;                  public StaticNestedClass(int temp, int staticvlaue) {             this.temp = temp;             StaticNestedClass.staticvalue = staticvlaue;         }         public int getTemp() {             return temp;         }         public static int getStaticvalue() {             return staticvalue;         }     } }   public static void main(String args[]){ \tTestClass.StaticNestedClass testClass = new TestClass.StaticNestedClass(10, 200); \t \tSystem.out.println(\"중첩 클래스 테스트  temp값: \" + testClass.getTemp()); \tSystem.out.println(\"중첩 클래스 테스트  staticvlaue값: \" + testClass.getStaticvalue()); \tSystem.out.println(\"중첩 클래스 테스트  staticvlaue값: \" + TestClass.StaticNestedClass.getStaticvalue()); }    1 2 3 4 // 결과  중첩 클래스 테스트  temp값: 10 중첩 클래스 테스트  staticvlaue값: 200 중첩 클래스 테스트  staticvlaue값: 200   로컬 클래스  로컬 클래스는 메소드 내에서 사용하고 사라지는 클래스로 접근 제한자 (public, private) 및 static을 사용할 수 없습니다. ( 정확히는 필요가 없습니다. ) 로컬 클래스는 주로 비동기 처리를 위해 스레드 객체를 만들 때 사용합니다. 나중 스레드 정리 후 추가로 포스트 하겠습니다. 추가로 중첩 클래스에서 바깥 클래스의 멤버를 참조할 때는 바깥클래스이름.this.멤버  public class TestClass {     // 로컬 클래스     private int temp = 1000;          public void testMethod() {         class NestedClass {             int temp;             NestedClass(int temp) {                 this.temp = temp;             }         }                  NestedClass nestedClass = new NestedClass(100);         System.out.println(\"로컬 클래스 테스트 : \" + ( TestClass.this.temp + nestedClass.temp ) );     } }  public static void main(String args[]){ \tTestClass testClass= new TestClass(); \ttestClass.testMethod(); }    1 2 // 결과  로컬 클래스 테스트 : 1100   중첩 인터페이스  중첩 인터페이스란 클래스의 멤버로서 선언된 인터페이스를 말합니다. 인터페이스를 별도의 파일로 분리하지 않고 클래스 내부에 선언하는 이유는 해당 클래스와 인터페이스가 긴밀한 관계로 이루어져 있어 있고, 별도의 분리 파일보단 해당 클래스에서 꼭 필요하고 해당 클래스에서만 필요한 인터페이스인 경우 선언하지 않을까 싶습니다. 특히 UI 프로그래밍에서 이벤트를 처리할 목적을 많이 활용된다고 합니다. 아래 예시는 Button을 클릭했을 때, Button 내부에 선언한 중첩 인터페이스를 구현한 클래스를 받고 싶을 때 처리 방법입니다.  public class TestClass {          private OnclikListener listener;          public void setOnclickLister( OnclikListener listener ) {         this.listener = listener;     }          public void touch() {         listener.onClick();     }          // 중첩 인터페이스     interface OnclikListener {         void onClick();     } }   public class NestedOnclickListener1Impl implements TestClass.OnclikListener {      @Override     public void onClick() {         System.out.println(\"전화를 겁니다.\");     }  }   public class NestedOnclickListener2Impl implements TestClass.OnclikListener {      @Override     public void onClick() {         System.out.println(\"메시지를 보냅니다.\");     }  }   public static void main(String args[]){ \tTestClass testClass= new TestClass(); \ttestClass.setOnclickLister(new NestedOnclickListener1Impl()); \ttestClass.touch(); \t \ttestClass.setOnclickLister(new NestedOnclickListener2Impl()); \ttestClass.touch(); }   1 2 3 // 결과  전화를 겁니다. 메시지를 보냅니다.   참고자료    – 이것이 자바다 (한빛 미디어)   ","categories": ["JAVA"],
        "tags": [],
        "url": "https://minesafety-eng.github.io//java/java-interface/",
        "teaser":null},{
        "title": "생성자 대신 정적 팩터리 메서드를 고려하라.",
        "excerpt":"정적 팩터리 메서드(Static Factory Method)란?  JAVA에서 정적 팩터리 메서드란 private 생성자를 통해 new를 통한 객체 생성을 감추고 static 메서드를 통해 객체 생성을 캡슐화하는 디자인 패턴을 말합니다. 기본적인 방법은 아래와 같습니다.  public class StaticFactoryMethod {      private int number;     private String address;     private String name;          private StaticFactoryMethod() {     }          private StaticFactoryMethod( int number ) {         this.number = number;     }          private StaticFactoryMethod( String address ) {         this.address = address;     }          private StaticFactoryMethod( int number, String name ) {         this.name = name;     }          static public StaticFactoryMethod getNewInstanceByNumber( int number ) {         return new StaticFactoryMethod( number );     }          static public StaticFactoryMethod getNewInstanceByAddress( String address ) {         return new StaticFactoryMethod( address );     }          static public StaticFactoryMethod getNewInstanceByName( String name ) {         StaticFactoryMethod temp = new StaticFactoryMethod();         temp.setName(name);         return temp;     }          static public StaticFactoryMethod getNewInstanceByNumberAndName( int number , String name ) {         return new StaticFactoryMethod( number, name );     }      public int getNumber() {         return number;     }      public void setNumber(int number) {         this.number = number;     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public String getAddress() {         return address;     }      public void setAddress(String address) {         this.address = address;     } }   public static void main(String args[]){     StaticFactoryMethod staticFactoryMethod = StaticFactoryMethod.getNewInstanceByNumber(10);     System.out.println(\"number : \" + staticFactoryMethod.getNumber()); }    1 2 // 출력  number : 10   이러한 정적 팩터리 메서드가 항상 좋은 것이 아닌 장단점이 존재하기 때문에 상황에 따라 적절하게 사용한다면 좋은 코드가 나올 것입니다.   장점 1 : 이름을 가질 수 있다.  일반적인 생성자로 객체를 생성한다면 new StaticFactoryMethod( 1, “김석진” ); 처럼 해당 매개변수가 무슨 의미를 뜻하는지 알기 어렵습니다. 이러한 상황에서 위의  케이스 처럼  정적 팩터리 메서드를 고려한다면 이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있습니다. StaticFactoryMethod.getNewInstanceByNumberAndName(1, “김석진”);   장점 2 : 호출될 때마다 인스턴스를 새로 생성하지 않도록 설계할 수 있다.  static으로 클래스객체를 미리 만들어 놓는다면 인스턴스 객체를 캐싱하여 재활용하여 불필요한 객체 생성을 낭비할 수 있습니다.   public class StaticFactoryMethod {     private static final StaticFactoryMethod STATIC_FACTORY_METHOD = new StaticFactoryMethod();          private StaticFactoryMethod() {}          static public StaticFactoryMethod getNewInstanceByNumber() {         return STATIC_FACTORY_METHOD;     }  }  public static void main(String args[]){     StaticFactoryMethod staticFactoryMethod = StaticFactoryMethod.getNewInstance();     StaticFactoryMethod staticFactoryMethod2 = StaticFactoryMethod.getNewInstance();          System.out.println(\"staticFactoryMethod == staticFactoryMethod2 :  \" +  ( staticFactoryMethod == staticFactoryMethod2 )); }    1 2 // 출력  staticFactoryMethod == staticFactoryMethod2 :  true   장점 3 : 반환 타입의 하위 타입 객체를 반환할 수 있다.  반환할 객체의 자유도를 높일 수 있기에 원하는 객체를 리턴 할 수 있습니다. 만약 특정 코드를 받아 코드에 따른 반환 객체를 자신 하위 타입 중 선택하게 한다면 아래와 같이 쉽게 처리할 수 있습니다.  public abstract class StaticFactoryMethod {          abstract void getName();          static public StaticFactoryMethod getNewInstance( String code ) {         StaticFactoryMethod staticFactoryMethod = null;         if( code.indexOf(\"2\") == 1 ) {             staticFactoryMethod = new Point();         } else {             staticFactoryMethod = new Coupon();         }         return staticFactoryMethod;     } } class Coupon extends StaticFactoryMethod {     public void getName() {         System.out.println(\"쿠폰을 발행합니다.\");     } }  class Point extends StaticFactoryMethod {     public void getName() {         System.out.println(\"포인트 1000점을 적립합니다.\");     } }   public static void main(String args[]){     StaticFactoryMethod staticFactoryMethod = StaticFactoryMethod.getNewInstance(\"223123\");     StaticFactoryMethod staticFactoryMethod1 = StaticFactoryMethod.getNewInstance(\"123123\");     staticFactoryMethod.getName();     staticFactoryMethod1.getName(); }   1 2 3 // 출력 쿠폰을 발행합니다. 포인트 1000점을 적립합니다.   장점 4 : 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.  장점 3과 비슷한 의미입니다. 예를 들면 같은 이름의 메서드지만 매개변수의 개수에 따라 리턴받는 클래스를 아무 하위타입 클래스를 리턴 받을 수 있다는 것입니다.  public abstract class StaticFactoryMethodType {     public abstract void getName();          static public StaticFactoryMethodType getNewInstance( String code ) {         return new OneClass();     }     static public StaticFactoryMethodType getNewInstance( String code, String name ) {         return new TwoClass();     }  }  class OneClass extends StaticFactoryMethodType {     public void getName() {         System.out.println(\"쿠폰을 발행합니다.\");     } }  class TwoClass extends StaticFactoryMethodType {     public void getName() {         System.out.println(\"포인트 1000점을 적립합니다.\");     } }  public static void main(String args[]){     StaticFactoryMethodType isOneObj = StaticFactoryMethodType.getNewInstance(\"code\");     StaticFactoryMethodType isTwoObj = StaticFactoryMethodType.getNewInstance(\"code\",\"name\");     isOneObj.getName();     isTwoObj.getName(); }   1 2 3 // 출력  쿠폰을 발행합니다. 포인트 1000점을 적립합니다.   장점 5 : 정적 팩터리 메서드를 작성하는 시점에서 반환할 객체의 클래스가 존재하지 않아도 된다.  장점 3, 4와 관련된 유연함에 관한 내용으로 메서드 안에서 객체를 반환할 때, 당장 클래스가 존재하지 않아도 특정 텍스트 파일에서 인터페이스 구현체의 위치를 알려주는 곳의 정보를 가지고 해당 객체를 읽어 생성할 수 있습니다.   package algorithm.dataStructure;  public abstract class StaticFactoryMethodType {          public abstract void getName();          public static StaticFactoryMethodType getNewInstance() {         StaticFactoryMethodType temp = null;         try {             Class&lt;?&gt; childClass = Class.forName(\"algorithm.dataStructure.StaticFactoryMethodTypeChild\");             temp = (StaticFactoryMethodType) childClass.newInstance();                      }catch (ClassNotFoundException e) {            System.out.println(\"클래스가 없습니다.\");         } catch (InstantiationException  e) {             System.out.println(\"메모리에 올릴수 없습니다.\");         } catch (IllegalAccessException  e) {             System.out.println(\"클래스파일 접근 오류입니다.\");         }                  return temp;     } }   package algorithm.dataStructure;  public class StaticFactoryMethodTypeChild extends StaticFactoryMethodType {      @Override     public void getName() {         System.out.println(\"정상 로드 되었습니다\");     }  }  public static void main(String args[]){     StaticFactoryMethodType staticFactoryMethodType = StaticFactoryMethodType.getNewInstance();          staticFactoryMethodType.getName(); }   1 2 // 결과  정상 로드 되었습니다   단점  private 생성자만 제공한다면 상속이 되지 않습니다. 하위 타입의 클래스 상속을 허용하려면 public 혹은 protected 생성자가 필요합니다. 또한, 정적 팩터리 메서드를 사용하기 위해서는 해당 클래스를 인스턴스화 하는 방법을 찾아야 합니다. new를 통한 인스턴스화는 모든 개발자가 알고 있지만 매서드를 통해 제공한다면 찾아야 합니다.   참고자료    – Effectie Java 3/E - 조슈아 블로크  –  https://www.youtube.com/watch?v=X7RXP6EI-5E&amp;t=456s  (백기선 강사님 강의)  –  https://johngrib.github.io/wiki/static-factory-method-pattern/   ","categories": ["JAVA"],
        "tags": ["이펙티브 자바( Effective Java )"],
        "url": "https://minesafety-eng.github.io//java/effective-java-static-factory-method/",
        "teaser":null},{
        "title": "JAVA 쓰레드란(Thread) ? - JAVA에서 멀티쓰레드 사용하기",
        "excerpt":"Step 1 : 멀티 스레드( Multi Thread )의 개념  운영체제(OS)에서 실행 중인 하나의 어플리케이션 즉 ctrl + alt + del창 작업 관리자에서 프로세스 탭에 올라와 있는 어플리케이션 하나를 하나의 프로세스라고 부릅니다. ( Ex) Chrome )  만약 우리가 크롬창을 더블클릭 누른다면(실행) 운영체제로부터 필요한 메모리를 할당받아 어플리케이션의 코드를 실행하는 것이 프로세스입니다.  크롬을 2개 띄웠다면 두 개의 프로세스가 생성된 것입니다.   멀티 태스킹( Multi Tasking )과 멀티 스레드( Multi Thread )  멀티 태스킹이란 두 가지 이상의 작업을 동시에 처리하는 것을 말합니다.  예를 들어 워드로 문서작업을 하는 동시에 음악을 듣는 것은 OS가 프로세스마다 작업을 병렬로 처리하기에 가능합니다.  멀티 태스킹이 꼭 멀티 프로세스( 워드 + 윈도 플레이어 프로세스 조합 )를 말하는 것은 아닙니다.  한 프로세스 내에서 멀티 태스킹을 할 수 있도록 만들어진 프로세스 예를 들어 메신져 프로세스 같은 경우 채팅 기능을 제공하면서 동시에 파일 업로드 기능을 수행할 수 있습니다.  이처럼 한 프로세스에서 멀티 태스킹이 가능한 이유는 멀티 스레드 ( Multi Thread )덕분 입니다.  멀티 프로세스는 프로세스마다 운영체제로부터 할당받은 고유의 메모리를 서로 침범할 수 없지만 멀티 스레드는 /java/java-jvm/ 포트스에서 확인할 수 있는 것처럼 프로세스 내부에서의 멀티 스레드는 공유되는 자원이 있어 하나의 스레드에서 예외가 발생한다면 프로세스 자체가 종료될 수 있습니다.   Step 2 : Main Thread  모든 자바 어플리케이션은 Main Thread가 main() 메소드를 실행하면서 시작됩니다.  예외는 없습니다. 이러한 Main Thread 흐름 안에서 싱글 스레드가 아닌 멀티 스레드 어플리케이션은 필요에 따라 작업 쓰레드를 만들어 병렬로 코드를 실행할 수 있습니다.  싱글 스레드 같은 경우 메인 스레드가 종료되면 프로세스도 종료되지만, 멀티 스레드는 메인 스레드가 종료되더라도 실행 중인 스레드가 하나라도 있다면 프로세스는 종료되지 않습니다.   Thread 생성  이제 쓰레드를 어떻게 생성하는지 알아보겠습니다. 쓰레드 생성에는 2가지의 방법이 존재합니다.   Thread 클래스로부터 직접 생성  new를 통해 Thread 클래스 객체를 생성 후 start 메서드를 통해 다른 스레드에서 할 작업을 할당하는 방법입니다.  Thread객체를 생성할 때는 Runnable 인터페이스를 구현한 클래스 객체를 매개변수로 받습니다.   public class Task implements Runnable {      @Override     public void run() {         int sum = 0;         for (int index = 0; index &lt; 10; index++) {             sum += index;             System.out.println(sum);         }         System.out.println( Thread.currentThread() + \"최종 합 : \" + sum);     }  }   public static void main(String args[]){     Runnable task = new Task();     Thread subTread1 = new Thread(task);     Thread subTread2 = new Thread(task);     subTread1.start();     subTread2.start(); }    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 결과 ( 스레드가 끝나는 순서는 랜덥입니다. ) 0 1 3 6 10 15 21 28 36 45 0 1 3 Thread[Thread-0,5,main]최종 합 : 45 6 10 15 21 28 36 45 Thread[Thread-1,5,main]최종 합 : 45   꼭 Runable을 구현한 객체를 파일로 만들지 않고  익명-구현-객체만들기 포스트 방법처럼 익명 구현 객체로 만들어 간단하게 실행 가능합니다.   public static void main(String args[]){     Runnable task = new Runnable() {         public void run() {             int sum = 0;             for (int index = 0; index &lt; 10; index++) {                 sum += index;                 System.out.println(sum);             }             System.out.println( Thread.currentThread() + \"최종 합 : \" + sum);         }     };     Thread subTread1 = new Thread(task);     Thread subTread2 = new Thread(task);     subTread1.start();     subTread2.start(); }   더 간단한 방법은 람다식을 통해 익명 구현 객체를 구현하는 것입니다. 추후 람다식 포스트를 통해 자세히 소개하겠습니다.   public static void main(String args[]){     Runnable task = ()-&gt; {         int sum = 0;         for (int index = 0; index &lt; 10; index++) {             sum += index;             System.out.println(sum);         }         System.out.println( Thread.currentThread() + \"최종 합 : \" + sum);     };          Thread subTread1 = new Thread(task);     Thread subTread2 = new Thread(task);     subTread1.start();     subTread2.start(); }    Thread 하위 클래스로부터 생성  스레드가 실행할 작업을 Runable 구현클래스 대신 Thread를 상속한 새로운 클래스를 정의하여 run 메소드를 Overriding 하는 방법입니다.  혹은 코드를 단순히 하기 위해 Thead 익명 객체로 작업 스레드 객체를 생성할 수 있습니다.   // Thread클래스를 상속한 클래스 public class CustomThread extends Thread {          @Override     public void run() {         int sum = 0;         for (int index = 0; index &lt; 10; index++) {             sum += index;             System.out.println(sum);         }         System.out.println( Thread.currentThread() + \"최종 합 : \" + sum);      } }   public static void main(String args[]){     Thread subTread1 = new CustomThread();          // 익명 객체 생성     Thread subTread2 = new Thread() {         public void run() {             int sum = 0;             for (int index = 0; index &lt; 10; index++) {                 sum += index;                 System.out.println(sum);             }             System.out.println( Thread.currentThread() + \"최종 합 : \" + sum);         }     };          subTread1.start();     subTread2.start(); }    데몬 스레드  데몬 스레드는 메인 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드로 주 스레드가 종료되면 데몬 스레드 더는 존재 의미가 없기에 강제로 종료됩니다.  워드의 자동 저장 기능을 예로 들을 수 있습니다. 데몬 스레드를 만드는 방법은 스레드를 만들고 해당 스레드에 setDaemon(true); 메소드를 세팅하는 것입니다.   public static void main(String args[]){     Thread deamon = new Thread(()-&gt;{         while ( true ) {             System.out.println(\" 데몬 스레드가 실행 중입니다.\");             try {                 Thread.sleep(1);             } catch (InterruptedException e) {                 // TODO Auto-generated catch block                 e.printStackTrace();             }         }     });          deamon.setDaemon(true);     deamon.start();           try {         Thread.sleep(10);     } catch (InterruptedException e) {         // TODO Auto-generated catch block         e.printStackTrace();     } }   1 2 3 4 5 6 7 8 9 10 11 12 // 결과   데몬 스레드가 실행 중입니다.  데몬 스레드가 실행 중입니다.  데몬 스레드가 실행 중입니다.  데몬 스레드가 실행 중입니다.  데몬 스레드가 실행 중입니다.  데몬 스레드가 실행 중입니다.  데몬 스레드가 실행 중입니다.  데몬 스레드가 실행 중입니다.  데몬 스레드가 실행 중입니다.  // while(true) 지만 Main Thread가 종료됨에 따라 자동 종료됨   Thread 이름 생성  기본 스레드는 thread.getName()을 통해 Thread-n이라는 이름을 가지고 올 수 있습니다. 하지만 조금 더 수월한 디버깅을 위해 thread.setName(“스레드 이름”)을 통해 스레드의 이름을 설정할 수 있습니다.   public static void main(String args[]){     Thread subTread1 = new CustomThread();     Thread subTread2 = new Thread() {         public void run() {             int sum = 0;             for (int index = 0; index &lt; 10; index++) {                 sum += index;                 System.out.println(sum);             }             System.out.println( Thread.currentThread().getName() + \"최종 합 : \" + sum);         }     };     subTread1.setName(\"스레드 1번입니다.\");     subTread2.setName(\"스레드 2번입니다.\");     subTread1.start();     subTread2.start(); }   1 2 3 // 출력  스레드 1번입니다.최종 합 : 45 스레드 2번입니다.최종 합 : 45   Step 3 : Thread 우선순위  동시성과 병렬성  멀티 스레드는 동시성( Concurrency ) 또는 병렬성( Parallelism )으로 실행됩니다. 동시성이랑 멀티작업을 위해 1개의 코어로 스레드마다 돌아가면서 조금씩 실행하지만, 너무 빨라 사람의 눈에 보기에는 독립적으로 돌아가는 것처럼 보이는 것을 말하며 병렬성이란 스레드마다 각각의 독립적인 Core가 할당되어 독립적인 Core에서 작업이 이루어지는 것을 말합니다. 코어의 수보다 스레드의 수가 작으면 각각의 코어로 병렬성이 보장되지만 스레드의 개수가 코어보다 많은 경우 스레드를 어떤 순서에 의해 동시적으로 실행할 것인가를 결정해 주어야 합니다. 이것을 스레드 스케줄링이라 합니다. 이런 스케쥴링 방식은 우선순위( Priority ) 방식과 순환 할당( Round-Robin ) 방식으로 나누어집니다.   우선순위( Priority ) 방식  우선순위가 높은 스레드가 실행을 더 많이 하도록 스케줄링하는 방법입니다. thread.setPriority(1) // 1 - 우선순위가 가장 낮음 , 10 - 가장 높음 thread .setPriority(Thread.MAX_PRIORITY); // 직관적 코드 MAX_PRIORITY, NORM_PRIORITY, MIN_PRIORITY   순환 할당( Round-Robin ) 방식  시간 할당량을 정해서 하나의 스레드를 정해진 시간만큼만 실행하는 방법입니다. 해당 방식은 JVM안에서 이루어지기 때문에 개발자가 제어할 수 없습니다.     실질적으로 해당 작업을 다루어 본적은 없어 테스트 코드는 생략하겠습니다.   Step 4 :  동기화 메소드 또는 동기화 블록  멀티스레드 환경에서의 문제는 스레드들이 객체를 공유하며 작업하는 경우가 생기기 때문에 A스레드와 B스레드가 공유하는 객체가 서로의 작업에 영향을 미치면 안 되기 때문에 이를 방지하는 방법으로 동기화 메소드와 동기화 블록 방법이 있습니다. 아래 코드는 서로에게 영향을 미쳐 원하는 결과를 가지고 오지 못하는 경우입니다. thred1 에서 예상하는 값은 100을 가지고 오는 것입니다.  // 공유 객체 public class ShareThread {     private int value = 0;          public void setValue( int value ) {         this.value = value;         try {             Thread.sleep(2000);         } catch (Exception e) {         }         System.out.println(Thread.currentThread().getName() + \"의 Value 값은 \" + this.value +\"입니다.\");              }          public int getValue() {         return value;     } }   public static void main(String args[]){     ShareThread shareTread = new ShareThread();     Thread thred1 = new Thread(()-&gt;{         shareTread.setValue(100);              });          Thread thred2 = new Thread(()-&gt;{         shareTread.setValue(10);     });     thred1.setName(\"스레드 1\");     thred2.setName(\"스레드 2\");     thred1.start();     thred2.start(); }    1 2 3 // 결과  스레드 2의 Value 값은 10입니다. 스레드 1의 Value 값은 10입니다.   동기화 메소드 또는 동기화 블록 코드  스레드가 사용 중인 객체를 Lock을 걸어 해당 작업을 진행하는 Thread가 작업을 마칠 때까지 다른 쓰레드가 작업을 하지 못하게 하는 방법입니다. 메소드 선언에 synchronized를 붙이던가 ( 동기화 메소드 ) synchronized( 공유객체 ) { 작업 } 인 동기화 블록을 사용하면 됩니다.   // 동기화 메소드  public synchronized void setValue( int value ) {     this.value = value;     try {         Thread.sleep(2000);     } catch (Exception e) {     }     System.out.println(Thread.currentThread().getName() + \"의 Value 값은 \" + this.value +\"입니다.\");   }  // 동기화 블록  public  void setValue( int value ) {     synchronized ( this ) {         this.value = value;         try {             Thread.sleep(2000);         } catch (Exception e) {         }         System.out.println(Thread.currentThread().getName() + \"의 Value 값은 \" + this.value +\"입니다.\");     } }  하지만 Synchronized 키워드를 너무 남발하면 오히려 프로그램 성능저하를 일으킬 수 있기 때문에 적재 적소에 잘 사용해야 합니다.   Step 5 : 스레드 상태  스레드로 객체를 생성하면 우선 실행 대기 상태로 들어갑니다. 실행대기상태란 아직 스케쥴링 전 즉 코어에서 작업을 할당받지 못한 상태입니다. 실행 대기 상태에 있는 스레드 중 스레드 스케쥴링으로 선택된 스레드가 CPU를 점유하고 run()을 실행합니다. 이때 CPU를 점유하고 있는 상태를 실행상태입니다. 아직 run()메소드가 끝나지 않아도 스레드 스케쥴링에 의해 다시 실행 대기 상태로 돌아가며 번갈아 가면서 내용을 끝낼 때까지 지속합니다. 경우에 따라 run중인 쓰레드를 일시 정지 시킬 수도 있는데 예제에서 많이 보았던 sleep() 메서드와 같은 경우입니다. 일시 정지 후에는 다시 실행 대기 상태로 갑니다.   스레드 상태 제어  실행 중인 스레드 상태를 변경하는 것을 스레드 상태 제어라고 합니다. 멀티 프로그램을 만들기 위해서는 정교한 스레드 상태 제어가 필요합니다. 상태를 제어하는 메소드는 아래 그림과 같습니다. 취소선을 가지는 메소드들은 스레드의 안정성을 해칠 수 있다고 하여 더는 사용하지 않도록 권장되는 Deprecated 메소드들 이기 때문에 사용하지 않는 것이 좋습니다.    스레드 상태제어에 관해서는 필자가 스레드에 관해 아직 단순한 작업만 하여 머리로 체득한 상태가 아니라 좀 더 알게 된다면 해당 부분 수정하겠습니다.   Step 6 : 스레드 그룹  스레드 그룹이란 느낌이 오듯이 관련된 스레드를 그룹으로 묶어서 한 번에 관리하겠다는 목적으로 이용됩니다. 스레드 그룹이 제공하는 다양한 메소드를 통해서 그룹을 제어합니다. 아래 예제코드는 myGroup이라는 스레드 그룹을 만들고 interrupt()를 통해 해당 그룹에 속하는 모든 thread를 중지시키는 예제입니다.   public static void main(String args[]){     ThreadGroup root = new ThreadGroup(\"Root_Group\");     ThreadGroup groupChild = new ThreadGroup( root,\"myGroup\" );          // root 그룹에 세팅     Thread root_group = new Thread( root, ()-&gt;{         while ( true ) {             System.out.println(\"Root 그룹입니다.\");             try {                 Thread.sleep(1);             } catch (InterruptedException e) {                 System.out.println(\"Root 그룹 스레드가 종료됩니다.\");                 break;             }         }     });     // groupChild 그룹에 세팅     Thread child_group1 = new Thread( groupChild, ()-&gt;{         while ( true ) {             System.out.println(\"child_group 그룹의 child_group1입니다.\");             try {                 Thread.sleep(1);             } catch (InterruptedException e) {                 System.out.println(\"child_group 그룹의 child_group1 종료됩니다.\");                 break;             }         }     });          // groupChild 그룹에 세팅     Thread child_group2 = new Thread( groupChild, ()-&gt;{         while ( true ) {             System.out.println(\"child_group 그룹의 child_group2입니다.\");             try {                 Thread.sleep(1);             } catch (InterruptedException e) {                 System.out.println(\"child_group 그룹의 child_group2 종료됩니다.\");                 break;             }         }     });          root_group.start();     child_group1.start();     child_group2.start();               try {         Thread.sleep(5);     } catch (InterruptedException e) {         // TODO Auto-generated catch block         e.printStackTrace();     }          //groupChild그룹 일괄 중지      System.out.println(\"======= groupChild 일괄 중지 =======\");     groupChild.interrupt();          try {         Thread.sleep(5);     } catch (InterruptedException e) {         // TODO Auto-generated catch block         e.printStackTrace();     }               //root그룹 일괄 중지     System.out.println(\"======= root 일괄 중지 =======\");     root.interrupt(); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 결과  Root 그룹입니다. child_group 그룹의 child_group1입니다. child_group 그룹의 child_group2입니다. child_group 그룹의 child_group2입니다. Root 그룹입니다. child_group 그룹의 child_group1입니다. child_group 그룹의 child_group2입니다. child_group 그룹의 child_group1입니다. Root 그룹입니다. child_group 그룹의 child_group1입니다. Root 그룹입니다. child_group 그룹의 child_group2입니다. ======= groupChild 일괄 중지 ======= child_group 그룹의 child_group2 종료됩니다. child_group 그룹의 child_group1 종료됩니다. Root 그룹입니다. Root 그룹입니다. Root 그룹입니다. ======= root 일괄 중지 ======= Root 그룹입니다. Root 그룹 스레드가 종료됩니다.   Step 7 : 스레드풀  스레드풀 생성  지금까지 스레드를 만드는 방법에 대해 알아보았습니다. 이제 스레드를 통해 병렬 작업 처리가 많아진 스레드를 효율적으로 처리하는 방법에 대해 알아보겠습니다. 스레드가 기하급수적으로 늘어난다면 스레드 생성과 스케줄링으로 인해 CPU의 메모리 사용량이 늘어나고 어플리케이션의 성능의 저하가 일어납니다. 병렬작업의 급증을 막기 위해서는 특정 스레드 개수 + 작업 컨베이어 벨트 ( 작업 큐 )를 만들어 놓고 작업을 컨베이어 벨트에 올려놓아 작업이 끝난 스레드가 컨베이어에서 작업을 꺼내 기능을 수행하는 방식으로 작업을 구성한다면 분업화로 인한 업무효율이 향상 될 수 있습니다. 아무리 작업 처리 요청이 폭주하여도 스레드의 전체 개수가 늘어나지 않기 때문에 어플리케이션의 성능이 급격하게 저하되지 않습니다. 자바는 스레드 풀을 생성하고 사용할 수 있도록 java.utile.concurrent.ExecutorService 인터페이스와 Executors 클래스 메소드 중 newCachedThreadPool과 newFixedThreadPool 메소드를 제공하고 있습니다.   // 스레드 풀 생성  //1. 자동으로 스레드 수 생성 ExecutorService executorServiceWithCached = Executors.newCachedThreadPool();  //2. 원하는 개수만큼 생성 ExecutorService executorServiceWithNum = Executors.newFixedThreadPool(2);  //3. 최대치로 생성 ExecutorService executorServiceWithMax = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());  //4. 완전 수동 // ThreadPoolExecutor( 코어 스레드 수, 최대 스레드 개수, 놀고 있는 시간, 놀고있는 시간 단위, 작업 큐 ) ExecutorService executorServiceWithCustom = new ThreadPoolExecutor(3, 100, 120L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());   스레드풀 종료  스레드풀의 스레드는 데몬스레드가 아니므로 main이 종료되더라도 작업을 처리하기 위해 계속 실행상태로 남아있습니다. 때문에 어플리케이션을 종료할 때는 해당 스레드풀을 종료시켜 스레드풀 안의 스레드를 종료상태가 되도록 처리해야 합니다.   // 1. 작업 큐에 대기하고 있는 모든 작업이 끝난 뒤 스레드를 종료한다.  executorServiceWithCached.shutdown();  // 2. 당장 중지한다. 리턴값은 작업큐에 남아있는 작업의 목록이다. List&lt;Runnable&gt; runable = executorServiceWithCached.shutdownNow();  // 3. 작업은 대기 하지만 모든 작업처리를 특정 시간안에 하지 못하면 작업중인 스레드를 중지하고 false를 리턴한다. 아래는 100초 설정 try {     boolean isFinish = executorServiceWithCached.awaitTermination(100, TimeUnit.SECONDS); } catch (InterruptedException e) {     // TODO Auto-generated catch block     e.printStackTrace(); }   작업의 생성  Runable 또는 Callable 구현 클래스로 작업을 생성합니다. 둘의 차이는 작업이 끝난 후 리턴 값이 있냐 없느냐의 차이입니다.   // Runable 구현 객체 ( 익명구현객체 사용  ) Runnable task1 = ()-&gt; {     for (int index = 0; index &lt; 10; index++) {         System.out.println(\"작업 중입니다.\");         try {             Thread.sleep(10);         } catch (InterruptedException e) {             e.printStackTrace();         }     } };   // Callable 구현  Callable&lt;Boolean&gt; task2 = () -&gt;{     Boolean isFinish = true;          for (int index = 0; index &lt; 10; index++) {         System.out.println(\"작업 중입니다. Call\");         try {             Thread.sleep(10);         } catch (InterruptedException e) {             e.printStackTrace();         }     }          return isFinish; };   작업처리 요청  task를 컨베이어 벨트에 올리는 작업입니다. 즉 작업큐에 위 task객체를 넣는 것입니다.   // 1. 리턴 값이 없는 단순 Runnable를 처리합니다. executorServiceWithCached.execute(task1);  // 2. 리턴 가능한 Callable도 넣을 수 있는 메서드 입니다. Future&lt;Boolean&gt; returnBoolean =  executorServiceWithCached.submit(task2);  try {     System.out.println(\"끝났습니까 : \" + returnBoolean.get()); } catch (Exception e) { }   execute와 submit의 차이는 return을 받느냐 못 받느냐의 차이 추가로 execute()는 작업 도중 오류 발생 시 오류가 난 스레드를 스레드풀에서 제거하지만 submit()은 오류가 발생하여도 해당 스레드를 재사용합니다.   작업완료 통보  submit()은 task 작업을 작업큐에 넣고 바로 Futrue객체를 리턴합니다. 해당 객체의 get()메서드를 호출하면 호출한 순간부터 스레드가 작업을 완료할 때까지 대기하고 있다가 완료된 후 결과를 받아옵니다.   public static void main(String args[]){     // 스레드 풀 생성      //자동으로 스레드 수 생성     ExecutorService executorServiceWithCached = Executors.newCachedThreadPool();          // Runable 구현 객체 ( 익명구현객체 사용  )     Runnable task1 = ()-&gt; {         for (int index = 0; index &lt; 100; index++) {             System.out.println(\"작업 중입니다.\");             try {                 Thread.sleep(10);             } catch (InterruptedException e) {                 e.printStackTrace();             }         }     };           // Callable 구현      Callable&lt;Boolean&gt; task2 = () -&gt;{         Boolean isFinish = true;                  for (int index = 0; index &lt; 100; index++) {             System.out.println(\"작업 중입니다. Call\");             try {                 Thread.sleep(10);             } catch (InterruptedException e) {                 e.printStackTrace();             }         }                  return isFinish;     };          // 1. 리턴 값이 없는 단순 Runnable를 처리합니다.     executorServiceWithCached.execute(task1);          // 2. 리턴 가능한 Callable도 넣을 수 있는 메서드 입니다.     Future&lt;Boolean&gt; returnBoolean =  executorServiceWithCached.submit(task2);          // main스레드의 작업이 멈추지 않기 위해 새로운 스레드로 구성      executorServiceWithCached.execute(()-&gt;{         try {             if( returnBoolean.get() ) {                 System.out.println(\"작업이 완벽히 끝났습니다. \");             } else {                 System.out.println(\"작업이 끝나지 못했습니다.\");             }         } catch (Exception e) {         }      });          // main스레드의 작업이 멈추지 않기 위해 새로운 스레드로 구성     executorServiceWithCached.execute(()-&gt;{         try {             // 만약 특정 시간 내에 끝났는지 확인하려는 경우             if( returnBoolean.get(1,TimeUnit.SECONDS) ) {                 System.out.println(\"작업이 완벽히 끝났습니다. \");             }          } catch (Exception e) {             System.out.println(\"작업이 시간내에 끝나지 못했습니다.\");         }      });          // 작업 큐에 대기하고 있는 모든 작업이 끝난 뒤 스레드를 종료한다.      executorServiceWithCached.shutdown(); }   작업처리 결과를 외부 객체에 저장  상황에 따라 스레드가 작업한 결과를 외부 공유 객체에 저장하고 추후 합산하여 저장하는 경우가 있을지도 모릅니다. 예를 들어 쓰레드 1은 1~100까지의 합을 쓰레드 2는 101~200까지의 합을 구하여 두 결과를 합산하는 예를 구현해 보겠습니다. 외부객체 주입은 Runable 인터페이스를 구현하는 클래스를 정의하고 생성자에서 주입 받는 형식으로 진행하겠습니다.   public class FirstThread implements Runnable {          ResultShare resultShare;           //공유객체 외부에서 주입.     public FirstThread ( ResultShare resultShare ) {         this.resultShare = resultShare;     }          @Override     public void run() {         int result = 0;         for (int index = 1; index &lt;= 100; index++) {             result += index;             try {                 Thread.sleep(10);             } catch (InterruptedException e) {                 // TODO Auto-generated catch block                 e.printStackTrace();             }         }         System.out.println(\"1~100까지의 합은 \" + result +\"입니다.\");         resultShare.sum(result);         resultShare.showSum();     }  }   public class SecondThread implements Runnable {          ResultShare resultShare;           //공유객체 외부에서 주입.     public SecondThread ( ResultShare resultShare ) {         this.resultShare = resultShare;     }          @Override     public void run() {         int result = 0;         for (int index = 101; index &lt;= 200; index++) {             result += index;         }         System.out.println(\"101~200까지의 합은 \" + result +\"입니다.\");         resultShare.sum(result);         resultShare.showSum();     }  }   public class ResultShare {     private int result;          public int sum( int number ) {         return result+=number;     }          public void showSum() {         System.out.println(\" 지금 저장된 값은 : \" + result + \"입니다.\");     }          public int getResult() {         return result;     } }   public static void main(String args[]){     // 스레드 풀 생성      //자동으로 스레드 수 생성     ExecutorService executorServiceWithCached = Executors.newCachedThreadPool();          ResultShare resultShare = new ResultShare();          Runnable task1 = new FirstThread(resultShare);     Runnable task2 = new SecondThread(resultShare);                  // Runable이라도 작업이 끝난 후 Future&lt;리턴 객체&gt;로 무엇을 받을 지 임의로 정할 수 있다. run()의 리턴값으로 아무 값이 없더라도 종료 후에 아무 원하는 객체를 이런 식으로 리턴할 수 있다.     Future&lt;ResultShare&gt; future1 =  executorServiceWithCached.submit( task1, resultShare );     Future&lt;ResultShare&gt; future2 =  executorServiceWithCached.submit( task2, resultShare );          // main스레드의 작업이 멈추지 않기 위해 새로운 스레드로 구성     executorServiceWithCached.execute(()-&gt;{         try {             ResultShare temp = future1.get();             temp = future2.get();            System.out.println(\"쓰레드 합산이 끝났습니다. 최종 결과는 : \" + resultShare.getResult());         } catch (Exception e) {         }      });          // 작업 큐에 대기하고 있는 모든 작업이 끝난 뒤 스레드를 종료한다.      executorServiceWithCached.shutdown(); }   1 2 3 4 5 6 7 // 실행 결과 101~200까지의 합은 15050입니다.  지금 저장된 값은 : 15050입니다.  1~100까지의 합은 5050입니다.  지금 저장된 값은 : 20100입니다. 쓰레드 합산이 끝났습니다. 최종 결과는 : 20100   작업 완료 순으로 통보  일반적으로 작업 순서대로 처리가 완료되는 것이 아니기 때문에 끝나는 것은 랜덤입니다.  여러 개의 작업이 차례대로 처리될 필요가 없고 처리 결과도 차례대로 이용할 필요가 없다면 CompletionService 인터페이스를 구현한 ExecutorCompletionService 클래스를 사용하면 됩니다. 사용 방법은 아래와 같습니다.   public static void main(String args[]){     // 스레드 풀 생성      //자동으로 스레드 수 생성     ExecutorService executorServiceWithCached = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());          ResultShare resultShare = new ResultShare();          Runnable task1 = new FirstThread(resultShare);     Runnable task2 = new SecondThread(resultShare);                  Future&lt;ResultShare&gt; future1 =  executorServiceWithCached.submit( task1, resultShare );     Future&lt;ResultShare&gt; future2 =  executorServiceWithCached.submit( task2, resultShare );          // 각각의 테스트들의 리턴 결과의 객체를 &lt;ResultShare&gt; 안에 적어줍니다.      CompletionService&lt;ResultShare&gt; compliCompletionService = new ExecutorCompletionService&lt;ResultShare&gt;(executorServiceWithCached);          executorServiceWithCached.submit(()-&gt;{         // 작업 최종 통보가 올때까지 while 문을 통해 대기합니다.          while(true) {             try {                 // 작업이 끝난 결과를 받아온다.                 Future&lt;ResultShare&gt; take = compliCompletionService.take();                 ResultShare result = take.get();                                  System.out.println(\"지금 까지의 합산은 \" + result.getResult() + \"입니다.\");             } catch ( Exception e) {                 break;             }          }     });          // 3초 뒤 스레드 강제 중지      try {         Thread.sleep(3000);         executorServiceWithCached.shutdownNow();     } catch (InterruptedException e) {     } }    1 2 3 4 5 6 // 결과   101~200까지의 합은 15050입니다.  지금 저장된 값은 : 15050입니다. 1~100까지의 합은 5050입니다.  지금 저장된 값은 : 20100입니다.    콜백 방식의 통보  이번에는 while통해 지속적으로 관찰하는 것이 아닌 Callback 방식을 이용하여 작업 완료를 통보받는 방법에 대해 알아보겠습니다. 콜백이란 작업이 끝나면 실행될 것을 미리 정의해 놓고 작업이 끝나는 순간 이어받아 call한다고 보면 됩니다. 콜백이 정의된 CompletionHandler를 사용해보겠습니다.   public class ResultShare {     private int result;     //&lt;결과 타입, 첨부타입&gt;     private static CompletionHandler&lt;ResultShare, String&gt; completionHandler = new CompletionHandler&lt;ResultShare, String&gt;() {                  //실패 시 할 일         @Override         public void failed(Throwable exc, String attachment) {             System.out.println(\"실패하였습니다.\");         }                  //성공 시 할 일         @Override         public void completed(ResultShare result, String attachment) {              System.out.println(\"지금까지의 저장된 합은 \" + result.getResult() + \"입니다.\");         }     };          public int sum( int number ) {         return result+=number;     }          public void showSum() {         System.out.println(\" 지금 저장된 값은 : \" + result + \"입니다.\");     }          public int getResult() {         return result;     }          public static CompletionHandler&lt;ResultShare, String&gt; getCompletionHandler() {         return completionHandler;     } }   public class FirstThread implements Runnable {          ResultShare resultShare;           //공유객체 외부에서 주입.     public FirstThread ( ResultShare resultShare ) {         this.resultShare = resultShare;     }          @Override     public void run() {         int result = 0;         for (int index = 1; index &lt;= 100; index++) {             result += index;         }         System.out.println(\"1~100까지의 합은 \" + result +\"입니다.\");         resultShare.sum(result);                  // 끝난 후 성공 콜백 실행         resultShare.getCompletionHandler().completed(resultShare, null);     } }   public class SecondThread implements Runnable {          ResultShare resultShare;           //공유객체 외부에서 주입.     public SecondThread ( ResultShare resultShare ) {         this.resultShare = resultShare;     }          @Override     public void run() {         int result = 0;         for (int index = 101; index &lt;= 200; index++) {             result += index;         }         System.out.println(\"101~200까지의 합은 \" + result +\"입니다.\");         resultShare.sum(result);         // 끝난 후 콜백 실행         resultShare.getCompletionHandler().completed(resultShare, null);     } }  public static void main(String args[]){     // 스레드 풀 생성      //자동으로 스레드 수 생성     ExecutorService executorServiceWithCached = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());          ResultShare resultShare = new ResultShare();          Runnable task1 = new FirstThread(resultShare);     Runnable task2 = new SecondThread(resultShare);                  Future&lt;ResultShare&gt; future1 =  executorServiceWithCached.submit( task1, resultShare );     Future&lt;ResultShare&gt; future2 =  executorServiceWithCached.submit( task2, resultShare );          executorServiceWithCached.shutdown(); }   참고자료     – 이것이 자바다 (한빛 미디어)   ","categories": ["JAVA"],
        "tags": [],
        "url": "https://minesafety-eng.github.io//java/java-thread/",
        "teaser":null},{
        "title": "JAVA 제네릭이란(Generic)?",
        "excerpt":"JAVA 5부터 제네릭타입이 추가되었습니다.  제네릭타입을 사용하면 컴파일 과정에서 잘못된 타입사용을 미리 방지할 수 있다는 장점이 있습니다.  대부분의 API 도큐먼트를 보면 제네릭표현이 많으므로 API에 대한 깊은 이해를 위해서는 제네릭에 대한 이해는 필수입니다.   Step 1 : 제네릭 타입  제네릭 타입은 &lt;&gt;을 가지는 클래스와 인터페이스를 말합니다.  &lt;&gt;사이에는 &lt;T&gt;처럼 사용 시에 정해지는 즉 사용 시에 받아올 객체에 대한 파라메터를 대표합니다.  &lt;T&gt;&lt;G&gt; 등 원하는 문자를 넣어주면 됩니다. 그렇다면 이전 코드와 제네릭을 사용하는 코드를 비교해보겠습니다.  아래의 클래스는 원하는 객체를 넣어주던 코드입니다.   public class BeforeTest {     private Object object;      public void setObj( Object obj ) {         this.object  = obj;     }          public Object getObj() {         return object;     } }  public static void main(String args[]){     BeforeTest beforeTest = new BeforeTest();     Integer tempInt = 100;     beforeTest.setObj(tempInt);     int sum = (Integer)beforeTest.getObj() + 1000;     System.out.println(\"합은 : \" + sum); }   1 2 // 결과  합은 : 1100   위의 코드는 아쉬운 점은 모든 객체를 받아서 Setting 할 수 있지만 사용 시에 사용 객체로 형 변환 해야 합니다.  또한 저장 시에도 보이진 않지만 Integer 객체가 Object 객체로 형 변환됩니다. 이런 문제를 해결한 제네릭을 이용한 방법입니다.  클래스명 뒤에 &lt;T&gt;을 붙이고 클래스 내부 T에서 T를 사용할 수 있습니다. 클라이언트 코드에서 T에 대한 타입을 정해줍니다.   public class BeforeTest &lt;T&gt;{     private T object;      public void setObj( T obj ) {         this.object  = obj;     }          public T getObj() {         return object;     } }   public static void main(String args[]){     BeforeTest&lt;Integer&gt; beforeTest = new BeforeTest&lt;Integer&gt;();     Integer tempInt = 100;     beforeTest.setObj(tempInt);     int sum = beforeTest.getObj() + 1000;     System.out.println(\"합은 : \" + sum); }   Step 2 : 멀티 타입 파라미터  제네릭 타입은 두 개 이상의 파라메터를 클라이언트 측에서 받아오고 싶을 때 &lt; A , B , …&gt; 처럼 사용할 수 있습니다.  public class BeforeTest &lt; A, B, C&gt;{     private A first;     private B second;     private C third;      public void setFirst( A first ) {         this.first  = first;     }          public void setSecond( B second ) {         this.second= second;     }          public void setThird( C third ) {         this.third = third;     }          public void show() {         System.out.println(\"A의 타입은 : \" + first.getClass().getTypeName());         System.out.println(\"B의 타입은 : \" + second.getClass().getTypeName());         System.out.println(\"C의 타입은 : \" + third.getClass().getTypeName());     } }   public static void main(String args[]){     BeforeTest&lt;String, Integer, Double&gt; beforeTest = new BeforeTest&lt;&gt;();     beforeTest.setFirst(\"안녕하세요\");     beforeTest.setSecond(10);     beforeTest.setThird(100.0);     beforeTest.show(); }   1 2 3 4 // 결과  A의 타입은 : java.lang.String B의 타입은 : java.lang.Integer C의 타입은 : java.lang.Double   JAVA 7 이전에는 BeforeTest&lt;String, Integer, Double&gt; beforeTest = new BeforeTest&lt;String, Integer, Double&gt;() 처럼 new 뒤에도 &lt;&gt;안 내용을 명시해야 했지만 java 7 이후에는 생략하여 BeforeTest&lt;String, Integer, Double&gt; beforeTest = new BeforeTest&lt;&gt;() 가 가능해졌습니다.  이를 다이아몬드 연산자라고 부릅니다.   Step 3 : 제네릭 메소드  제네릭 메소드는 매개타입 또는 리턴타입으로 타입파라메터를 갖는 메소드를 말합니다.  선언하는 방법은 리턴타입 앞에 &lt;&gt;를 추가하고 적어줍니다.  즉 메소드에서 사용할 부분을 리턴타입 내부 &lt;&gt;에 적어주고 뒤에서 사용하면 됩니다. 사용 방법은 아래와 같습니다.   public class BeforeTest  {     public &lt;T&gt; void show( T inputObj ) {         if( inputObj.getClass().getTypeName().equals(String.class.getTypeName()) ) {             System.out.println(\"문자입니다.\");             System.out.println(inputObj);         } else if( inputObj.getClass().getTypeName().equals(Integer.class.getTypeName()) ) {             System.out.println(\"숫자입니다.\");             System.out.println(inputObj);         }     } }   public class Main {     public static void main(String args[]){     BeforeTest beforeTest = new BeforeTest();     beforeTest.show(\"문자열 주입\");     beforeTest.show(10); }   1 2 3 4 5 //출력 문자입니다. 문자열 주입 숫자입니다. 10   2개 이상 예제, Map에 해당 키가 담겨있나 확인하는 예제입니다.   public class BeforeTest  {     public &lt; T , D &gt; void show( Map&lt; T, D &gt; map, T key ) {         System.out.println(map.containsKey(key));     } }  public static void main(String args[]){     BeforeTest beforeTest = new BeforeTest();     Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();     map.put(100, \"100존재\");     map.put(10, \"10존재\");     beforeTest.show(map, 100);     beforeTest.show(map, 10);     beforeTest.show(map, 1); }   1 2 3 4 // 출력 true true false   지금까지의 코드는 구체적인 타입을 java가 알아서 추정하도록 코드를 짰습니다.  만약 구체적으로 타입을 명시하고 싶다면 위 클라이언트 코드에서 beforeTest.&lt; Integer, String &gt;show(map, 100); 처럼 명시할 수 있습니다.   Step 4 : 제한된 타입 파라미터  제네릭의 상위 타입을 구체적으로 제한하고 싶을 경우가 있습니다.  메서드, 인터페이스, 클래스에서 동일하게 사용 가능하며 &lt; T extends 상위타입&gt;으로 제한할 수 있습니다.  예를 들어 내부에서 사용할 T 객체가 꼭 Number 클래스의 하위 타입이어야 할 때, 혹은 원하는 상위 인터페이스의 구현체이어야 할 때 사용 가능합니다. 그래야 메소드 안에서 필요한 인터페스의 메소드 혹은 클래스의 메소드를 사용할 수 있습니다.   public class BeforeTest  {     public &lt; T extends Number, D extends Map &gt; void show( D map, T key ) {         System.out.println(map.containsKey(key));     } }  Step 5 : 와일드카드 타입.  코드에서 ?를 일반적으로 와일드카드라고 부릅니다. 사용하는 경우는 아래와 같습니다.     &lt;?&gt;  모든 클래스나 인터페이스가 올 수 있습니다. 즉 제한없음. A ~ E 모두 올 수 있다.  &lt;? extends 상위타입&gt;  상위타입 이하로만 올 수 있습니다. &lt;? extends D&gt; =&gt; D, E 가능   &lt;? supper 하위타입&gt;  하위타입 이상으로만 올 수 있습니다. &lt;? supper D&gt; =&gt; D, A 가능   참고자료     – 이것이 자바다 (한빛 미디어)   ","categories": ["JAVA"],
        "tags": [],
        "url": "https://minesafety-eng.github.io//java/java-generic/",
        "teaser":null},{
        "title": "JAVA 람다식이란(Lambda Expression)?",
        "excerpt":"Step 1 : 람다식이란?  람다식의 기본개념을 보기 전에 함수형 프로그래밍이 무엇인지 잠시 살펴보겠습니다.  함수형 프로그래밍이란 객체 지향 프로그래밍이 나오기 전부터 있던 패러다임 중 하나로서 함수 안으로 들어오는 인자를 가지고 항상 불변한 결과를 돌려주는 것이 목적으로서 f(  x , y  ) = c 처럼 x와 y라는 값이 들어오면 항상 c가 도출되도록 프로그래밍을 하는 것이라 보면 됩니다.  함수형 프로그램은 함수 내부 중괄호 안에 필요한 변수는 외부에서 받아오고 로직만이 존재하기 때문에 없어 변수에 값이 할당되면 이후 절대 변하지 않기 때문에 병렬처리나 이벤트 지향 프로그램에서 side effect가 없다는 장점이 있습니다.  이러한 함수적 프로그래밍을 쉽게 지원하기 위해 자바 8부터 람다식( Lambda Expresstion )을 지원하고 있습니다. 람다식은 ( 매개변수 ) -&gt; { 실행코드 } 형식으로 표현됩니다.  이런 코드들은 런타임시에 인터페이스의 익명 구현 개체로 생성됩니다. 관련 포스트는 익명구현객체란를 확인하시기 바랍니다.   Step 2 : 람다식 기본문법  람다식 기본 문법은 아래와 같습니다.   public interface Ramda {     public void justOne( int a, int b ); }  Ramda ramda = ( int a, int b ) -&gt; {     System.out.println(a + b); };  ramda.justOne(2, 3);  다만 매개 변수에 대한 타입은 런타임시 자동으로 인식되기 때문에 생략 가능합니다.   Ramda ramda = ( a, b ) -&gt; {     System.out.println(a + b); };   만약 인터페이스가 하나의 매개변수만 있다면 ()도 생략 가능합니다.   public interface Ramda {     public void justOne( int a ); }    Ramda ramda = a -&gt; {     System.out.println(a); };  만약 하나의 실행문만 존재한다면 중괄호 {}도 생략 가능합니다.  Ramda ramda = a -&gt;  System.out.println(a);  만약 매개변수가 없더라도 () -&gt; 는 항상 적어주어야 합니다.       리턴이 있는 경우는 아래처럼 가능합니다.  Ramda ramda = a -&gt;  { return a+10; };  다만 중괄호에 return문만 존재하는 경우 아래처럼 가능합니다.  Ramda ramda = a -&gt; a+10;   Step 3 : 함수적 인터페이스  인터페이스 내부 추상 메서드가 1개인 경우에만 람다식을 이용해 구현 객체를 생성할 수 있습니다.  이러한 인터페이스를 함수적 인터페이스라고 합니다.  함수적 인터페이스라는 것을 구체적으로 명시하는 벙법은 @FunctionalInterface어노테이션을 사용하는 것입니다.   @FunctionalInterface public interface Ramda {     public int justOne( int a ); }  해당 어노테이션을 붙이고 내부에 2개 이상의 추상 메소드가 적혀 있으면 에러를 확인할 수 있습니다.   Step 4 : this 키워드  람다식 내부에서 사용할 수 있는 this키워드에 대한 설명입니다.  public class BeforeTest  {     public int outField = 10;     public class Inner {         int innerField = 20;                  public void method( int testValue ) {             Ramda ramda =  a -&gt; {                 // BeforeTest.this.outField : 바깥 변수                  // this.innerField : inner 클래스 변수                 // testValue 메소드 로컬 변수                  // a : justOne 실행시 받아오는 변수                  return BeforeTest.this.outField + this.innerField + testValue + a;             };                          System.out.println(ramda.justOne(10));         }     } }  public static void main(String args[]){     BeforeTest beforeTest = new BeforeTest();     BeforeTest.Inner inner = beforeTest.new Inner();     inner.method(100); }    Step 5 : 메소드 참조  메소드 참조는 매개변수를 그대로 전달하여 불필요한 매개변수를 줄이는 것을 목적으로 합니다. 아래는 위에서 배운 내용을 토대로 작성한 코드입니다.   @FunctionalInterface public interface Ramda {     public int justOne( int a, int b ); }  public static void main(String args[]){     Ramda ramda = ( a, b ) -&gt; Math.max( a, b );     System.out.println( ramda.justOne(10, 11) ); }   해당 내용을 메소드 참조를 통해 생략한다면 아래처럼 가능합니다.   public static void main(String args[]){     Ramda ramda = Math :: max;     System.out.println( ramda.justOne(10, 11) ); }   정적 메소드 참조  방법은 정적 메소드를 참조할 경우 클래스 이름(Math) 뒤 :: 를 붙이고 정적 메소드 이름 ( max )를 기술하면 됩니다.   인스턴스 메소드 참조  인스턴스 메소드 일 경우에 먼저 객체를 생성한 후 참조 변수 뒤에 :: 를 붙이고 메소드명을 기술하면 됩니다.  public class BeforeTest  {     public int sum( int a, int b ) {         return a + b;     } }   public static void main(String args[]){     BeforeTest beforeTest = new BeforeTest();     Ramda ramda = beforeTest :: sum;     System.out.println( ramda.justOne(10, 11) ) }   생성자 참조  객체 생성을 단순히 생성자 참조로 대치할 수 있습니다.   @FunctionalInterface public interface Ramda {     public BeforeTest justOne( int a, int b ); }   public class BeforeTest  {     int a;     int b;      public BeforeTest(int a, int b) {         this.a = a;         this.b = b;     }      }  public static void main(String args[]){     Ramda ramda = BeforeTest :: new; }   참고자료     – 이것이 자바다 (한빛 미디어)   ","categories": ["JAVA"],
        "tags": [],
        "url": "https://minesafety-eng.github.io//java/java-ramda/",
        "teaser":null},{
        "title": "JAVA 컬렉션(Collection)",
        "excerpt":"Step 1 : Collection Framework( List, Set, Map )  학창시절 java를 책으로 배울 당시에는 Collection Framework라는 큰 개념보다는 사용방법에 치중하여 이렇게 쓰는 것이구나 하고 넘어갔던 Collection Framework, 이번 기회에 조금 더 생각하며 정리해보고자 합니다.  우리는 개발을 하다 보면 각종 자료형과 구조화된 Class파일을 통해 생성한 객체 인스턴스 등을 다룹니다.  여기서 우리가 원하는 방식으로 생성한 class 객체 파일에 대해 해당 객체 내부 데이터를 가지고 정렬이 필요할 때도 있고, 검색해야 할 때도 있습니다. 아래와 같이 이름을 저장하기 위해 만든 클래스가 있다고 예를 들겠습니다.   public class NameClass {          private String firstName;     private String subName;          public NameClass(String firstName, String subName) {         super();         this.firstName = firstName;         this.subName = subName;     }      public String getFirstName() {         return firstName;     }      public String getSubName() {         return subName;     }      }   우리는 이제 5명의 이름을 받아 정렬하던, 삭제하던, 검색을 해야 합니다. 컬렉션을 알기 전이라면 단순 배열에 5명의 이름을 저장하고, for 문으로 배열을 돌면서 원하는 행위를 진행해야 합니다. 만약 배열에 추가적인 이름을 저장해야 한다거나 한다면? 배열의 크기도 확인해야 하고 크기가 부족하다면 더 키워야 하는 이슈 등 이런 이슈들을 미리 정리하여 널리 알려진 자료구조를 바탕으로 똑똑하신 분들이 java.util 패키지에 관련 인터페이스와 클래스를 미리 만들어 놓아 우리는 사용 및 응용하면 됩니다. 결론적으로 우리가 생성한 객체를 효율적으로 추가, 검색, 삭제하기 위해 미리 정해 놓은 라이브러리를 자바 Collection Framework라고 합니다. Collection Framework를 사용 방법은 어떤 목적으로 사용하느냐에 따라 달라집니다. List, Set, Map 인터페이스에는 어떻게 사용하는지 사용 방법에 관해 서술되어 있습니다. 이제 Collection Framework를 사용해 봅시다.   Step 2 : List 컬랙션  List 컬렉션을 사용하는 목적은 데이터들이 중복 저장이 가능할 때, 배열에 들어간 순서를 유지하고 싶을 때입니다. 해당 인터페이스의 기능들입니다.     boolean add( E 객체 ) : 주어진 객체를 list 컬렉션 맨 끝에 추가, 성공여부 반환   void add( int index, E 객체 ) : 주어진 객체를 list 컬렉션 주어진 인덱스에 추가   E set( int int, E 객체 ) : list 컬렉션 해당 인덱스에 위치한 객체를 들어온 객체로 교체하고, 기존에 있던 객체를 반환합니다.   boolean contains( E 객체 ) : 객체가 list 컬렉션 내부에 존재하는지 찾습니다.   E get( int index ) : list 컬렉션에서 주어진 index의 위치한 객체를 반환합니다.   boolean isEmpty() : list 컬렉션이 비어있는지 반환합니다.   int size() : list 컬렉션의 사이즈를 리턴합니다.   void clear() : list 컬렉션에 저장된 모든 객체를 삭제합니다.   E remove(int index) : list 컬렉션에서 해당 index 위치의 객체를 삭제하고 반환합니다.   boolean remove(int index) : list 컬렉션 해당 index 위치의 객체를 삭제하고 성공여부를 반환합니다.   이런 list의 기능이 정의된 인터페이스를 구현한 클래스 3가지를 알아보겠습니다.   ArrayList     장점 : 검색이 빠르다. 순차적으로 데이터가 추가된다면 빠르다.   단점 : list들의 중간 중간 데이터에 빈번한 추가 삭제가 일어난다면 느리다. List 컬렉션을 여러 스레드에서 공유해야 한다면 Thread safe 하지 않다.   Vector     ArrayList와 내부 구조는 동일하지만 Thread safe하다.   LinkedList     장점 : 중간에 빈번한 삭제와 삽입이 일어날 때 좋은 성능을 발휘한다.   단점 : 검색이 느리다.   public static void main(String args[]){     List&lt;NameClass&gt; listImpl = new ArrayList&lt;&gt;();     listImpl.add(new NameClass(\"박\", \"석진\"));     listImpl.add(new NameClass(\"김\", \"석진\"));     listImpl.add(new NameClass(\"차\", \"석진\"));     listImpl.add(new NameClass(\"이\", \"석진\"));     for (NameClass nameClass : listImpl) {         System.out.println(nameClass.getFirstName()+nameClass.getSubName());     } }   public static void main(String args[]){     List&lt;NameClass&gt; listImpl = new Vector();     listImpl.add(new NameClass(\"박\", \"석진\"));     listImpl.add(new NameClass(\"김\", \"석진\"));     listImpl.add(new NameClass(\"차\", \"석진\"));     listImpl.add(new NameClass(\"이\", \"석진\"));     for (NameClass nameClass : listImpl) {         System.out.println(nameClass.getFirstName()+nameClass.getSubName());     } }   public static void main(String args[]){     List&lt;NameClass&gt; listImpl = new LinkedList&lt;&gt;();     listImpl.add(new NameClass(\"박\", \"석진\"));     listImpl.add(new NameClass(\"김\", \"석진\"));     listImpl.add(new NameClass(\"차\", \"석진\"));     listImpl.add(new NameClass(\"이\", \"석진\"));     for (NameClass nameClass : listImpl) {         System.out.println(nameClass.getFirstName()+nameClass.getSubName());     } }   1 2 3 4 박석진 김석진 차석진 이석진   Step 3 : Set 컬랙션  Set 컬랙션을 사용하는 목적은 순서가 필요 없고, set에 저장될 데이터가 중복이 되면 안될 때 입니다. 해당 인터페이스의 기능들 입니다. ( 단 LinkedHashSet은 순서도 보장합니다. )     boolean add( E 객체 ) : 주어진 객체를 set 컬렉션에 저장합니다.   boolean contains( E 객체 ) : 객체가 set 컬렉션 내부에 존재하는지 찾습니다.   Itorator interator() : set 컬렉션에 저장된 객체를 가져오는 반복자를 반환합니다.   boolean isEmpty() : 컬렉션이 비어있는지 반환합니다.   int size() : 컬렉션의 사이즈를 리턴합니다.   void clear() : 컬렉션에 저장된 모든 객체를 삭제합니다.   boolean remove(E 객체) : 컬렉션에서 해당 객체를 삭제합니다.   이런 set의 기능이 정의된 인터페이스를 구현한 클래스 2가지를 알아보겠습니다.   HasshSet  객체를 저장하기 전에 저장할 객체의 hashCode() 메소드를 호출해서 해쉬코드를 알아내고, set 내부의 hashCode와 비교하여 없을 때 저장한다. thread safe 하지 않다.   TreeSet  기본적으로는 같지만 기본적으로 오름차순 정렬하여 저장한다. thread safe 하지 않다.   LinkedHashSet  입력된 순서대로 저장한다. thread safe 하지 않다.   public static void main(String args[]){     List&lt;NameClass&gt; listImpl = new LinkedList&lt;&gt;();     listImpl.add(new NameClass(\"박\", \"석진\"));     listImpl.add(new NameClass(\"김\", \"석진\"));     listImpl.add(new NameClass(\"차\", \"석진\"));     listImpl.add(new NameClass(\"이\", \"석진\"));     for (NameClass nameClass : listImpl) {         System.out.println(nameClass.getFirstName()+nameClass.getSubName());     } }  public static void main(String args[]){     List&lt;NameClass&gt; listImpl = new LinkedHashSet&lt;&gt;();     listImpl.add(new NameClass(\"박\", \"석진\"));     listImpl.add(new NameClass(\"김\", \"석진\"));     listImpl.add(new NameClass(\"차\", \"석진\"));     listImpl.add(new NameClass(\"이\", \"석진\"));     for (NameClass nameClass : listImpl) {         System.out.println(nameClass.getFirstName()+nameClass.getSubName());     } }   1 2 3 4 5 // 랜덤 LinkedHashSet는 순서대로 출력 차석진 이석진 김석진 박석진   Step 4 : Map 컬랙션  Map 컬랙션을 사용하는 목적은 데이터를 저장할 때, key와 value 쌍으로 저장하고 싶을 때, 그리고, key를 중복 저장하고 싶지 않을 때입니다. 해당 인터페이스의 기능들입니다.     E put( K 객체, E 객체 ) : 주어진 K 객체를 키로, E 객체를 값으로 컬렉션에 추가합니다. 성공 시 E 객체를 반환합니다.   boolean containsKey( E 객체) : 컬렉션에 해당 객체를 Key로하는 객체 존재 여부를 반환합니다.   boolean containsValue( E 객체 ) : 해당 객체를 값으로 하는 객체가 컬렉션에 존재 하는지 반환합니다.   E get( V key) : 컬렉션에서 해당 key객체를 찾아 값을 반환합니다.   boolean isEmpty() : 컬렉션이 비었는지 확인합니다.   set keySet() : 컬렉션의 모든 key객체를 Set 객체에 담아 반환합니다.   int size() : 컬렉션의 길이를 반환합니다.   Colletion values() : 저장된 모든 값을 Colleciton에 담아 반환합니다.   void clear() : 컬렉션의 모든 데이터를 제거합니다.   E remove( E key ) : 컬렉션에서 해당 key객체를 가지는 부분을 제거합니다.   이런 Map의 기능이 정의된 인터페이스를 구현한 클래스 4가지를 알아보겠습니다.   HashMap  기본적인 Map 컬렉션의 특징을 구현한 클래스로 만약 HashMap의 key로 사용할 객체는 hashCode()와 equlas() 메소드를 재정의해서 동등 객체가 될 조건을 정해야 합니다. ( 해당 부분은 추후 Effective Java에서 본 내용을 기반으로 추가 포스트 하겠습니다. ) String 객체의 경우 이런 부분이 잘 정의되어 있어 key값으로 많이 사용합니다. thread safe 하지 않습니다.   Hashtable  HashMap과 동일한 내부 구조를 가지고 있습니다. 다만 thread safe합니다.   Properties  Hashtable의 하위 클래스입니다. 특징은 key값을 String으로 제한한 클래스라고 보시면 됩니다. 주로 사용 목적은 .properties파일을 읽을 때 사용합니다.   TreeMap  key값으로 오름차순 정렬되어 저장됩니다.   public static void main(String args[]){     Map&lt;String,NameClass&gt; listImpl = new HashMap&lt;&gt;();         listImpl.put(\"1\",new NameClass(\"박\", \"석진\"));         listImpl.put(\"2\",new NameClass(\"김\", \"석진\"));         listImpl.put(\"3\",new NameClass(\"차\", \"석진\"));         listImpl.put(\"4\",new NameClass(\"이\", \"석진\"));         for (String key : listImpl.keySet()) {             System.out.println(listImpl.get(key).getFirstName()+listImpl.get(key).getSubName());         }     } }  public static void main(String args[]){     Map&lt;String,NameClass&gt; listImpl = new Hashtable&lt;&gt;();         listImpl.put(\"1\",new NameClass(\"박\", \"석진\"));         listImpl.put(\"2\",new NameClass(\"김\", \"석진\"));         listImpl.put(\"3\",new NameClass(\"차\", \"석진\"));         listImpl.put(\"4\",new NameClass(\"이\", \"석진\"));         for (String key : listImpl.keySet()) {             System.out.println(listImpl.get(key).getFirstName()+listImpl.get(key).getSubName());         }     } }  public static void main(String args[]){      Map&lt;Object, Object&gt; listImpl = new Properties();         listImpl.put(\"1\",new NameClass(\"박\", \"석진\"));         listImpl.put(\"2\",new NameClass(\"김\", \"석진\"));         listImpl.put(\"3\",new NameClass(\"차\", \"석진\"));         listImpl.put(\"4\",new NameClass(\"이\", \"석진\"));         for (Object key : listImpl.keySet()) {             System.out.println(((NameClass) listImpl.get(key)).getFirstName()+((NameClass) listImpl.get(key)).getSubName());         }     } }   1 2 3 4 5 / 랜덤 박석진 김석진 차석진 이석진   Step 5 : Comparable과 Comparator  TreeSet의 객체와 TreeMap객체는 오름차순 정렬되어 있다고 설명해 드렸습니다. 우리가 초반에 만든 NameClass의 내부의 값인 firstName값을 가지고 해당 조건을 만족시키고 싶다면, 정렬을 위해 NameClass에서 Comparable 인터페이스 내부 CompareTo() 메소드를 구현해야 합니다. Compareble 을 구현할 수 없는 클래스의 경우 TreeSet 및 TreeMap 생성 시 Comparator 인터페이스를 구현한 객체를 제공해 주면 됩니다. 복잡한 상황에서 CompareTo 정렬은 깊이가 필요하여 해당 부분만 따로 포스트 추가하겠습다.    // Comparable 구현 시  public class NameClass implements Comparable&lt;NameClass&gt;{          private String firstName;     private String subName;          public NameClass(String firstName, String subName) {         super();         this.firstName = firstName;         this.subName = subName;     }      public String getFirstName() {         return firstName;     }      public String getSubName() {         return subName;     }      @Override     public int compareTo(NameClass input) {         return firstName.compareTo(input.firstName);     }      }  public static void main(String args[]){    Set&lt;NameClass&gt; treeSet = new TreeSet&lt;&gt;();    treeSet.add(new NameClass(\"박\", \"석진\"));    treeSet.add(new NameClass(\"김\", \"석진\"));    treeSet.add(new NameClass(\"차\", \"석진\"));    treeSet.add(new NameClass(\"이\", \"석진\"));    for (NameClass nameClass : treeSet) {        System.out.println(nameClass.getFirstName()+nameClass.getSubName());    } }    // 생성자에서 comparator 인터페이스 구현 시  public static void main(String args[]){     Set&lt;NameClass&gt; treeSet = new TreeSet&lt;&gt;( (NameClass first, NameClass second)-&gt; first.getFirstName().compareTo(second.getFirstName()) );      treeSet.add(new NameClass(\"박\", \"석진\"));     treeSet.add(new NameClass(\"김\", \"석진\"));     treeSet.add(new NameClass(\"차\", \"석진\"));     treeSet.add(new NameClass(\"이\", \"석진\"));     for (NameClass nameClass : treeSet) {         System.out.println(nameClass.getFirstName()+nameClass.getSubName());     } }    1 2 3 4 5 // 출력 김석진 박석진 이석진 차석진   Step 6 :  LIFO와 FIFO 컬렉션  Last In First Out(LIFO)는 문자 그대로 마지막에 들어온 아이템을 먼저 내보내는 후입 선출을 위한 자료구조입니다. LIFO를 제공하는 클래스는 Stack 클래스입니다. Fist In First Out은 선입 선출 구조를 위한 자료구조로 해당을 위해 Queue 인터페이스가 존재하겠습니다.   stack     push ( E 객체 ) : 주어진 객체를 스택에 넣습니다.   peek() : 마지막에 들어간 객체를 반환합니다.   pop() : 마지막에 들어간 객체를 제거하고 반환합니다.   queue  Queue 인터페이스 메소드를 한번 살펴보겠습니다.     offer( E 객체 ) : 주어진 객체를 넣습니다.   peek() : 객체 하나를 가지고 옵니다.   poll(): 객체 하나를 가지고 오고 queue에서 제거합니다.   구현 클래스로는 LinkedList 클래스가 존재하겠습니다.   해당 포스트에서 다루지 않은 것은 많습니다. 각각의 자료구조의 특성들 예를 들어 ArrayList 내부가 어떤 식으로 구성되어 있는지, TreeMap 내부 이진트리가 어떤 식으로 구성되어 있는지, 시간복잡도, 공간복잡도는 어떻게 되는지, 각각의 특징들과 deque같은 추가적인 인터페이스 등등 모든 것을 정리한 것은 아닙니다. 단지 Collection Framework이란 무엇인지 처음 접했을 때 직관적으로 이해가 되지 않았던 부분과 뜬금없이 인터페이스가 왜 나오고, 해당 인터페이스를 구현한 클래스가 어떤 역할을 하는지 정도에 대해 정리하고 싶어 가벼운 부분만 포스트를 작성하였습니다. 조금 더 학문적으로 깊은 부분(자료구조, 알고리즘)은 공부하시는 것이 좋습니다.   참고자료     – 이것이 자바다 (한빛 미디어)   ","categories": ["JAVA"],
        "tags": [],
        "url": "https://minesafety-eng.github.io//java/java-collection/",
        "teaser":null},{
        "title": "JAVA 스트림(Stream)",
        "excerpt":"Step 1 : 스트림(Stream)과 병렬처리  Stream의 장점은 흔히들 가독성을 꼽습니다. 여러 줄의 코드가 한 줄로 줄어드는 마법같은 일을 할 수 있게 Java 8 Stream API에서 제공해 주고 있습니다.   다만 Stream을 실무에서 사용하기 위해서는 충분한 공부와 학습이 필요합니다. 특히 개인 뿐만이 아니라 팀원 들도 충분히 Stream을 알아야 하기에.. 아쉽게도 아직은 Stream으로 제대로 된 작업을 진행해 본적이 없습니다.   안쓰면 잘 잊어버리기에 깊이 있는 포스트는 못 되더라도 책보고 기본적인 코드만 정리하겠습니다.(단순 남의 코드를 해석하기 위한) Stream을 사용하기 위해서는 꼭 다른 주의사항 같은 포스트를 읽어보고 Stream의 단점 및 주의사항을 확인하는 것이 좋습니다.   // 기존 코드  public class Student {     private String name;     private int age;      public Student(String name, int age) {         this.name = name;         this.age = age;     }      public String getName() {         return name;     }      public int getAge() {         return age;     } }   public static void main(String args[]){              List&lt;Student&gt; students = Arrays.asList(                  new Student(\"김석진\", 10),                 new Student(\"이석진\", 11),                 new Student(\"박석진\", 13)             );          for (Student student : students) {         System.out.println(student.getName() + \" \" + student.getAge()+\"살.\");          } }   1 2 3 김석진 10살. 이석진 11살. 박석진 13살.   // 스트림 사용  public static void main(String args[]){              List&lt;Student&gt; students = Arrays.asList(                  new Student(\"김석진\", 10),                 new Student(\"이석진\", 11),                 new Student(\"박석진\", 13)             );          Stream&lt;Student&gt; studentStream = students.stream();     studentStream.forEach( student -&gt; System.out.println(student.getName() + \" \" + student.getAge()+\"살.\") ); }  Step 2 : 스트림 사용하기  스트림을 사용하기 위해서는 스트림 객체를 얻어야 합니다. 아래는 다양하게 스트림을 얻는 방법을 기술하였습니다.   컬렉션에서 얻기  List&lt;String&gt; texts = Arrays.asList(\"1\",\"2\"); Stream&lt;String&gt; stream = texts.stream(); Stream&lt;String&gt; parallelStream = texts.parallelStream();   배열에서 얻기  String[] texts = {\"1\",\"2\"}; Stream&lt;String&gt; stream = Arrays.stream(texts);   숫자 범위로부터 스트림 얻기  IntStream intStream = IntStream.rangeClosed(1, 100); LongStream longStream = LongStream.rangeClosed(1, 100);    디렉토리에서 스트림 얻기  Stream&lt;Path&gt; directory = Files.list( Paths.get(\"D:/over_the_dream/NaverCloud/3.Programming\"));   파일로부터 스트림 얻기  Stream&lt;String&gt; file = Files.lines( Paths.get(\"D:/over_the_dream/NaverCloud/3.Programming/1.개발 요청 사항들.txt\"),Charset.defaultCharset());   Step 3 : 스트림 중간처리  스트림을 얻었다면 for문을 돌면서 중간 처리과정을 통해 데이터를 정제할 수 있습니다. 관련 메서드입니다.   distinct() : 중복 제거 filter(...) : 조건 필터링 , true를 만족하는 요소만 필터링한다. flatMapXXX() : 스트림의 요소를 복수개의 구성요소로 대체하고 합쳐 새로운 스트림을 생성한다. mapXXX() :  스트림의 요소를 새로운 구성요소로 대체하고 합쳐 새로운 스트림을 생성한다. asXXXStream() : 형변환.  boxed() : 기본 타입을 방싱타입으로 형변환 sorted(...) : 요소를 정렬하여 필터링 peak(...) : 요소 전체를 반복    Step 4 : 스트림 최종처리  xxxMatch(...) : 스트림 요소 중 해당 조건에 만족하는 요소 여부를 boolean으로 반환합니다. count() : 요소의 개수를 리턴 findFirst() : 첫번째 요소를 리턴 리턴 타입은 OptionalXXX max( ... ) : 최대 요소를 리턴합니다. 리턴타입은 OptionalXXX min(...) : 최소 요소를 리턴합니다. 리턴타입은 OptionalXXX average() : 요소의 평균을 리턴합니다. 리턴타입은 OptionalDouble sum() : 요소의 총 합을 리턴합니다. 리턴타입은 int, long, double collect(...) : 최종 요소들을 Collection 객체로 담습니다.    참고자료     – 이것이 자바다 (한빛 미디어)   ","categories": ["JAVA"],
        "tags": [],
        "url": "https://minesafety-eng.github.io//java/java-stream/",
        "teaser":null},{
        "title": "JAVA 자료구조 1(Data Structure)",
        "excerpt":"Step 1 : 자료구조(Data Structure)란 무엇인가?  자료 구조란 현실 세계 및 추상적 세계에서의 Data들의 모임 또 이런 Data들의 관계 등 Data들의 집합을 의미합니다. 신중히 선택한 자료구조 혹은 설계된 자료구조는 더 효율적인 알고리즘을 사용할 수 있게 하며 실행시간 및 메모리 용량과 같은 자원을 최소한으로 사용하면서 연산을 수행하도록 해줍니다. 자료구조는 원하는 형식으로 만들 수도 있으며, 지금부터 기존에 널리 알려진 자료구조 및 알고리즘을 풀면서 필요했던 다양한 자료구조에 대해 정리해 보겠습니다.   Step 2 : 단순구조  기본적으로 제공하는 자료형 및 추가로 정리한 자료형(BigDecimal)   정수     byte, short, long, int, long   실수     float, double   BigDecimal   BigDecimal  실수형 소수점 사칙연산의 한계를 극복하며 큰 수를 다루기 위해 사용됩니다. 단점은 느립니다.  BigDecimal number1 = new BigDecimal(“0.001”); BigDecimal number2 = new BigDecimal(“0.0007”);   더하기  number1 + number2 = number1.add(number2)   빼기  number1 - number2 = number1.subtract(number2)   곱하기  number1 * number2 = number1.multiply(number2)   나누기  number1.divide(number2, 3, RoundingMode.UP) // 올림 number1.divide(number2, 3, RoundingMode.HALF_UP) // 반올림 number1.divide(number2, 3, RoundingMode.DOWN) // 버림   나머지  number1.remainder(number2)   절대값  number1.abs()   최소값  number1.min(number2)   최대값  number1.max(number2)   논리적 비교  if( number1.compareTo(number2) == 1 ) {     System.out.println(\"number1 &gt; number2\"); } else if( number1.compareTo(number2) == 0 ) {     System.out.println(\"number1 == number2\"); } else {     System.out.println(\"number1 &lt; number2\"); }    문자     char   문자열     String   Step 3 : 선형구조  리스트( List )  일반적으로 List형 자료구조는 배열과 같이 일자로 나열되어 서로 연결된 자료구조를 말합니다. 배열과의 차이점은 빈틈없이 자료를 적재하는 것이 목적인 자료구조입니다. 자료 중간의 삭제가 일어난다면 중간의 자료를 제거하고 앞뒤 연결이 필요합니다.   순차리스트  배열을 기반으로 구현된 리스트입니다.  장 : index로 바로 데이터를 가지고 올 수 있어 검색이 빠릅니다. 단 : 중간 데이터의 삭제가 일어난다면 삭제 후 다시 정리하는 과정이 필요하다는 것이 단점이기에 중간 데이터의 빈번한 수정이 일어난다면 추천하지 않습니다.   List&lt;Integer&gt; numberList= new ArrayList&gt;();   연결리스트  데이터가 서로 연결된 형태의 자료형입니다.  장 : 데이터의 추가 삭제는 위치정보 수정만으로 가능하여 정보의 추가 삭제가 일어날 때 유용합니다. 단 : 검색을 위해서 자료를 순차적으로 확인해야 하기 때문에 검색에는 비효율 적입니다.   단순 연결 리스트 ( simple linked list )  가장 단순한 형태로 현재의 노드들은 다음 노드를 가리키는 하나의 참조 만을 가지고 있기에 한쪽 방향의 노드의 접근만 가능합니다.      이중 연결 리스트( double linked list )  끝점과 시작점이 연결된 구조입니다.    원형 연결 리스트 ( Circular linked list )  단순 연결 리스트 자료구조에서 마지막 노드를 첫 노드와 연결한 구조입니다.      위와 같은 개념적인 형상을 기반으로 원하는 형식으로 자료구조를 만들면 됩니다. 가볍게 이중 연결 리스트 자료구조를 만드는 방법을 보여드리겠습니다. java에서 제공하는 LinkedList 같은 경우 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있는 자료구조입니다. 이제 제일 복잡해 보이는 double linked list를 구현해 보겠습니다. 그리고 해당 자료구조를 만드는 데 필요한 add, remove 메서드, 그리고 특정 index 위치의 데이터를 추출하기 위한 get 메서드, 전체를 순회하는 toString메서드를 구현하겠습니다.   public class  DoubleLinkedList&lt;E&gt; {     private Node&lt;E&gt; head;     private Node&lt;E&gt; tail;     private int size = 0;          public void add( E item ) {         Node&lt;E&gt; temp = new Node&lt;&gt;( item );         if( tail == null ) {             head = temp;             tail = temp;         } else {             Node&lt;E&gt; lastNode = getNode(size-1);             lastNode.next = temp;             temp.before = lastNode;             temp.next = head;             head.before = temp;             tail = temp;         }         System.out.println(temp.item +\"이 삽입되어씁니다.\");         size++;     }     private void checkingValidataion( int index ) {         if( size &lt; index + 1 ) {             throw new IndexOutOfBoundsException(\"size를 확인하세요\");         }      }     public void remove( int index ) {         Node&lt;E&gt; temp = getNode(index);         Node&lt;E&gt; nextNode = temp.next;         Node&lt;E&gt; beforeNode = temp.before;         beforeNode.next = nextNode;         nextNode.before = beforeNode;         System.out.println(temp.item +\"이 지워졌습니다.\");         if( index == 0 ) {             head = nextNode;         }         if( size == 1 ) {             head = null;             tail = null;         } else if( index == size-1 ) {             tail = beforeNode;         }         size--;     }          public E get( int index ) {         Node&lt;E&gt; temp = getNode(index);                  return temp.item;     }          private Node&lt;E&gt; getNode( int index ) {         checkingValidataion(index);         Node&lt;E&gt; temp;         // 효율적 탐색을 위한 설계         if ( index &lt; size / 2 ) {             // 앞에서 부터 찾기              temp = head;             for (int inner = 0; inner &lt; index; inner++) {                 temp = head.next;             }         } else {             //뒤에서 부터 찾기           temp = tail;             for (int inner = size - 1; inner &gt; index; inner--) {                 temp = temp.before;             }         }         return temp;     }          @Override     public String toString() {         if( size == 0 ) {             return \"노드가 비었습니다.\";         }         StringBuilder result = new StringBuilder();         Node&lt;E&gt; temp = head;         for( int index = 0; index &lt; size; index++ ) {             result.append(\"노드 순회 index : \").append(index).append(\" \").append(temp.item).append(\"\\n\");             temp = temp.next;         }         return result.toString();     }     // DoubleLinkedList에서 사용할 중첩클래스     private static class Node&lt;E&gt; {         E item;         Node&lt;E&gt; next;         Node&lt;E&gt; before;          public Node(E item ) {             this.item = item;             this.next = null;             this.before = null;         }     } }    DoubleLinkedList&lt;Integer&gt; doubleLinked = new DoubleLinkedList&lt;&gt;(); doubleLinked.add(1); doubleLinked.add(2); doubleLinked.add(3); doubleLinked.add(4);  System.out.println(doubleLinked.toString());  doubleLinked.remove(2);  System.out.println(doubleLinked.toString());   1 2 3 4 5 6 7 8 9 10 11 12 13 1이 삽입되어씁니다. 2이 삽입되어씁니다. 3이 삽입되어씁니다. 4이 삽입되어씁니다. 노드 순회 index : 0 1 노드 순회 index : 1 2 노드 순회 index : 2 3 노드 순회 index : 3 4  3이 지워졌습니다. 노드 순회 index : 0 1 노드 순회 index : 1 2 노드 순회 index : 2 4   스택(Stack)     Stack이란 마지막에 들어온 데이터를 먼저 내보내는 후입선출(LIFO)을 표현하기 위한 자료구조입니다. 예를 들어 웹에서 History는 마지막 접근했던 페이지로 돌아가야 할 경우 이런 경우를 위해 사용하는 자료구조입니다. 위에서 작성했던 코드를 응용해서 push( 집어넣는 메서드 ), pop( 가져오는 메서드 ) 정도만 새로 작성한다면 기본적으로 사용할 수 있습니다.( 물론 push, pop 두 가지만으로는 불충분 합니다.) 필자는 자바에서 제공하는 java.util.Stack 라이브러리 stack을 사용하는 방법을 기술하겠습니다.      push() : 마지막 위치에 데이터 삽입   pop() : 마지막 데이터 제거 후 제거된 데이터 return   peek() : 마지막에 들어온 데이터를 return 합니다.   isEmpty() : stack이 비었는지 확인합니다.   Stack&lt;String&gt; stack = new Stack&lt;&gt;(); stack.push(\"first\"); System.out.println(\"삽입 : \" + stack.peek() ); stack.push(\"second\"); System.out.println(\"삽입 : \" +  stack.peek() ); stack.push(\"third\"); System.out.println( \"삽입 : \" + stack.peek() ); stack.push(\"forth\"); System.out.println( \"삽입 : \" + stack.peek() );  for( String item : stack  ){     System.out.println(\"순회 : \" + item); }  while( !stack.isEmpty() ) {     System.out.println(\"제거 : \" + stack.pop() );  }  System.out.println(\"Stack이 비었습니까 : \" + stack.isEmpty());   큐(Queue)      Queue란 먼저 들어온 데이터를 먼저 내보내는 선입선출(FIFO)을 표현하기 위한 자료구조입니다. 예를 들어 프린트나 테이블 예약 같은 경우 먼저 예약한 사람이 우선일 때 필요한 자료구조입니다.  java에서 que를 사용하기 위해서는 java.util.Queue를 구현한 클래스를 사용하면 됩니다. 내부 연결 구조를 배열로 만들었느냐, 연결 리스트 구조로 만들었느냐에 따라 내부 로직과 위 리스트에서 언급한 장단점이 생기게 되지만 사용법은 같습니다.      add() : que자료구조에 데이터 삽입.   peek() : 제일 먼저 들어와 상단에 위치한 데이터를 말합니다.   poll() : 상단에 위치한 데이터를 추출하고 que에서 제거 합니다. 추출한 데이터를 return합니다.   isEmpty() : stack이 비었는지 확인합니다.    Queue&lt;String&gt; queData = new ArrayDeque&lt;String&gt;(); // Queue&lt;String&gt; queData = new LinkedList&lt;String&gt;();   queData.add(\"first\"); queData.add(\"second\"); queData.add(\"third\"); queData.add(\"forth\");  for( String item : queData){     System.out.println(\"순회 : \" + item); }  while( ! queData.isEmpty() ) {     System.out.println(\"제거 : \" + queData.poll() );  }  System.out.println(\"queData가 비었습니까 : \" + queData.isEmpty());    우선순위 큐( Priority Queue )  선입 선출 구조의 Que와 다른 점은, 우선순위에 따라 우선순위가 높은 객체가 먼저 나오는 자료구조입니다. 우선순위 Que를 구현하는 방법은 배열 기반으로, 연결리스트를 기반으로, Heap을 이용하여 구현하는 방법이 존재합니다. 배열로 우선순위큐를 구현했을 경우 데이터 삽입, 삭제과정에서 데이터를 밀고 당기는 연산을 해야 하는 단점과 연결리스트로 우선순위 que를 구현하였을 경우 삽입의 위치를 찾기 위해 첫 번째 노드부터 마지막에 저장된 노드까지 순회해야 하는 기본적인 문제가 있어 더 좋은 성능을 발휘하는 Heap을 기반으로 구현하는 것이 일반적입니다. Heap은 tree 구조로 데이터를 정제하여 넣습니다. java.util.PriorityQueue을 사용한다는 것은 결국 heap을 구성하는 것이라고 봐도 무방합니다. 우선 Heap을 알기 전에 최종 목표인 Priority Queue의 사용법을 알아보겠습니다. 원론적으로 우선순위큐를 사용한다는 것은 Priority Queue에 들어갈 객체는 가중치가 다르다는 것이 기본이 됩니다. 그렇다면 Priority Queue에 들어갈 객체는 우선순위를 나타내기 위해 Comparable인터페이스의 compareTo 메서드를 구현하거나, 들어갈 객체를 변경할 수 없어 Comparable인터페이스를 구현하지 못하는 경우 Priority Queue생성 시 생성자로 Comparator인터페이스를 구현한 객체를 넘기면 됩니다. 두 방법 다 사용법을 확인해보겠습니다. 우선순위 큐에 넣을 객체는 Student로 시험 점수가 높은 사람을 top으로 위치하도록 우선순위 큐를 세팅하는 것입니다. 추가적인 욕심으로 동점자의 경우 사전식으로 정렬되도록 세팅하겠습니다. 아직 배우지 않았지만 java.util.PriorityQueue의 경우 기본 Heap구성은 minHeap으로 구성되기 때문에 상단에 위치한 데이터는 우선순위가 작은 값부터 위치한다고 보면됩니다. 당장 필요한 것은 우선순위가 높은 것이 위쪽에 위치하는 것이기 때문에 Comparator.reverseOrder()를 사용했다 정도만 이해하시면 되겠습니다. 그리고 우선순위가 높다는 것은 Comparator 혹은 compareTo 비교를 통해 +1 이 나오도록 하면 우선순위가 높다고 이해하시면 됩니다.   // Comparable 구현  public class Student implements Comparable&lt;Student&gt; {     private String name;     private int score;      public Student(String name, int score) {         this.name = name;         this.score = score;     }      @Override     public int compareTo(Student input) {         int result = Integer.compare(score, input.score);         if( result == 0 ) {             result = input.name.compareTo(name);         }         return result;     }          @Override     public String toString() {         return \"이름 : \" + name + \" 점수 : \" + score;     } }   PriorityQueue&lt;Student&gt; priorityQueue = new PriorityQueue&lt;&gt;(Comparator.reverseOrder()); priorityQueue.add(new Student(\"김석진\", 100)); priorityQueue.add(new Student(\"박석진\", 90)); priorityQueue.add(new Student(\"진석진\", 95)); priorityQueue.add(new Student(\"구석진\", 88)); priorityQueue.add(new Student(\"다석진\", 100)); priorityQueue.add(new Student(\"사석진\", 100)); priorityQueue.add(new Student(\"나석진\", 100));    1 2 3 4 5 6 7 8 // 출력  이름 : 김석진 점수 : 100 이름 : 나석진 점수 : 100 이름 : 다석진 점수 : 100 이름 : 사석진 점수 : 100 이름 : 진석진 점수 : 95 이름 : 박석진 점수 : 90 이름 : 구석진 점수 : 88   // comparator 이용  public class Student {     private String name;     private int score;      public Student(String name, int score) {         this.name = name;         this.score = score;     }      @Override     public String toString() {         return \"이름 : \" + name + \" 점수 : \" + score;     }      public String getName() {         return name;     }      public int getScore() {         return score;     }      }  PriorityQueue&lt;Student&gt; priorityQueue = new PriorityQueue&lt;&gt;( ( first, second )-&gt; {     int result = Integer.compare(second.getScore(), first.getScore());     if( result == 0 ) {         result = first.getName().compareTo(second.getName());     }     return result; }) ; priorityQueue.add(new Student(\"김석진\", 100)); priorityQueue.add(new Student(\"박석진\", 90)); priorityQueue.add(new Student(\"진석진\", 95)); priorityQueue.add(new Student(\"구석진\", 88)); priorityQueue.add(new Student(\"다석진\", 100)); priorityQueue.add(new Student(\"사석진\", 100)); priorityQueue.add(new Student(\"나석진\", 100));  while( !priorityQueue.isEmpty() ) {     Student student = priorityQueue.poll();     System.out.println(student.toString());      }    1 2 3 4 5 6 7 8 // 출력  이름 : 김석진 점수 : 100 이름 : 나석진 점수 : 100 이름 : 다석진 점수 : 100 이름 : 사석진 점수 : 100 이름 : 진석진 점수 : 95 이름 : 박석진 점수 : 90 이름 : 구석진 점수 : 88   Heap   Heap이란 우선순위를 둔 우선순위 큐를 위해 필요한 자료구조로 부모의 노드는 항상 자식의 노드보다 클 경우를 Max heap, 작을 경우를 Min Heap라고 합니다. 그럼 Max Heap, Min Heap 자료구조를 구성하기 위해 직관적으로 필요한 데이터를 넣는 add, 맨 위 데이터를 뽑은 pop 메서드를 구현해보겠습니다. 또한, 위와 같은 tree구조를 표현하기 위해 Node가 아닌 배열을 통해 완전이진트리를 구성하겠습니다. 배열을 통해 Tree이진 트리 구성은 관련은 아래에서 더 자세하게 다루겠습니다. MaxHeap 구현 방법입니다.      add() : Max Heap의 경우 마지막 노드에 값을 넣은 후 부모 노드와 비교 후 들어온 값이 크면 부모 노드와 교체한다. 최 상위 꼭대기까지 같은 로직을 반복한다.   pop() : Max Heap의 경우 꼭대기 값을 반환 후, 마지막 노드를 root 노드와 교체 후 자식 노드들과 크기 비교를 통해 자식이 클 경우 swap하는 로직을 통해 tree를 재구성 한다.   isEmpty() : Heap이 비었는지 확인한다.   public class MaxHeap &lt;T extends Comparable&lt;T&gt; &gt; {     private int maxSize;     private int pointer; // 마지막 노드의 위치를 저장하기 위해 필요     private Object[] heap;               public MaxHeap( int arrSize ){         arrSize++;         maxSize = 1;         pointer = 0;         while( maxSize &lt;= arrSize ) {             maxSize &lt;&lt;= 1;         }                  this.heap = new Object[arrSize];     }          public void add( T item ) {         if(isFull()) {             throw new ArrayIndexOutOfBoundsException();         }                  int tempIndex   = ++pointer;         heap[pointer] = item;                  while( tempIndex &gt; 0 &amp;&amp; tempIndex != 1) {             @SuppressWarnings(\"unchecked\")             T parentValue = (T) heap[tempIndex/2];                          if( parentValue.compareTo( item ) &lt; 0) {                 T swapData = parentValue;                 heap[tempIndex/2] = item;                 heap[tempIndex] = swapData;             } else {                 break;             }             tempIndex /= 2;         }     }          @SuppressWarnings(\"unchecked\")     public T pop() {         if(isEmpty()) {             throw new ArrayIndexOutOfBoundsException();         }         T result      = (T)heap[1];         T lastChild   = (T)heap[pointer];         heap[1]         = lastChild;         heap[pointer--] = 0;                  int tempIndex   = 1;         while( tempIndex*2 &lt;= pointer ) {             Boolean hasRightChild = tempIndex*2+1 &lt;= pointer;             T leftChild  = (T)heap[tempIndex*2];             T rightChild = (T)heap[tempIndex*2+1];             T parent     = (T)heap[tempIndex];             T changeValue = null;             int changeIndex;                          if( !hasRightChild ) {                                  if( parent.compareTo(leftChild)  &gt; 0 ) break;                 changeIndex = tempIndex*2;                 changeValue = leftChild;             } else {                 if( parent.compareTo(leftChild)  &gt; 0 &amp;&amp; parent.compareTo(rightChild)  &gt; 0 ) break;                                  changeValue = leftChild.compareTo(rightChild) &lt; 0? rightChild : leftChild;                 changeIndex = leftChild.compareTo(rightChild) &lt; 0? tempIndex*2+1 : tempIndex*2;                              }                          //교체             heap[tempIndex]    = changeValue;             heap[changeIndex]  = parent;             tempIndex = changeIndex;         }                  return result;     }          public boolean isEmpty() {         return pointer == 0;     }          private boolean isFull() {         return pointer &gt;= maxSize;     } }  MaxHeap&lt;Student&gt; maxHeap = new MaxHeap&lt;&gt;(7); maxHeap.add(new Student(\"김석진\", 100)); maxHeap.add(new Student(\"박석진\", 90)); maxHeap.add(new Student(\"진석진\", 95)); maxHeap.add(new Student(\"구석진\", 88)); maxHeap.add(new Student(\"다석진\", 100)); maxHeap.add(new Student(\"사석진\", 100)); maxHeap.add(new Student(\"나석진\", 100));    1 2 3 4 5 6 7 8 //출력 이름 : 김석진 점수 : 100 이름 : 나석진 점수 : 100 이름 : 다석진 점수 : 100 이름 : 사석진 점수 : 100 이름 : 진석진 점수 : 95 이름 : 박석진 점수 : 90 이름 : 구석진 점수 : 88   덱( Deque )   Deque란 Stack과 queue 양쪽으로 엘리먼트의 삽입과 삭제를 수행할 수 있는 자료구조 입니다.      add() : 데이터를 que형식으로 삽입합니다..   addFirst() : 데이터를 위에서 삽입합니다.(Stack 형식)        addLast() : 데이터를 아래에서 삽입합니다.(Que 형식 == add()  )       poll() : que의 poll과 같은 기능을 합니다.   pollFirst() : que의 poll과 같은 기능을 합니다.   pollLast() : deque의 하단에 tail 쪽의 데이터를 제거하고 return합니다.   //Deque&lt;String&gt; deque = new LinkedList&lt;&gt;(); Deque&lt;String&gt; deque = new ArrayDeque&lt;String&gt;();  deque.addLast(\"first\"); deque.addLast(\"second\"); deque.addLast(\"third\"); deque.addLast(\"forth\");  for( String item : deque  ){     System.out.println(\"순회 : \" + item); }  while( !deque.isEmpty() ) {     System.out.println(\"제거 : \" + deque.pollLast() );  }  System.out.println(\"Stack이 비었습니까 : \" + deque.isEmpty());    참고자료     – 윤성우의 열혈 자료구조 ( C언어 )    – 위키백과  ","categories": ["JAVA"],
        "tags": [],
        "url": "https://minesafety-eng.github.io//java/java-dataStructure-1/",
        "teaser":null},{
        "title": "JAVA 자료구조 2(Data Structure)",
        "excerpt":"Step 4 : 비선형구조  트리(Tree)   트리란 위에도 가볍게 언급한, 하나의 루트 노드와 0개 이상의 자식노드로 이루어진 자료구조입니다. 주로 계층적 관계( Hierarchical Relationship )를 표현하는 자료구조입니다.  트리관련 용어를 살펴보겠습니다.     Node (노드): A,B,C와 같은 요소입니다.   Root Node (루트노드): 최상위 노드 즉 A노드입니다.   Edge (간선) : 노드와 노드를 연결한 선입니다.   Terminal node, Leaf Node (단말노드) : 자식 노드가 없는 E, F, C, D와 같은 노드입니다.   Internal Node(내부노드) : 단말 노드가 아닌 A, B와 같은 노드입니다.   Degree(차수) : 자식 노드의 수를 말합니다.   Preorder Traversal( 전위 순회 ) : Root -&gt; 좌 -&gt; 우 순으로 Tree를 탐색하는 방법입니다.   Inorder Traversal( 중위 순회 ) : 좌 -&gt; root -&gt; 우 순으로 Tree를 탐색하는 방법입니다.   Postorder Traversal ( 후위 순회 ) : 좌 -&gt; 우 -&gt; root순으로 tree를 탐색합니다.   Tree의 자료구조를 표현하는 방법은 배열과 LinkedList로 표현할 수 있습니다.   이진 트리( Binary Tree )   각 노드가 최대 두 개의 자식을 갖는 Tree입니다. 꼭 자식 노드가 다 차지 않아도 됩니다.   완전 이진 트리 ( Complete Binary Tree )   마지막 레벨을 제외한 모든 노드는 채워져 있어야 하며 마지막 레벨은 왼쪽부터 채워져 있는 Binary Tree를 말합니다.   정 이진트리 ( Full Binary Tree )   모든 노드가 0개 또는 2개의 자식 노드를 갖는 이진트리입니다.   포화 이진트리 ( Perfect Binary Tree )   모든 레벨의 노드가 꽉 차있는 이진트리입니다.   이진 탐색 트리 ( Binary Search Tree )     중복된 값이 없으면서 왼쪽 자식 노드 값 &lt; root 노드 &lt; 오른쪽 자식 노드 값을 만족하는 이진트리입니다. root 노드 하위 왼쪽 노드 집합들은 root 노드 값보다 작아야 하며 우측 집합은 커야 합니다.      Tree구조로 할 수 있는 것은 다양합니다. 언급하지는 않았지만, Expression Tree와 같은 형태로 들어온 데이터를 구성할 수도 있고 새로운 형식의 데이터를 만들어 담을 수도 있습니다. 이제 Tree를 어떻게 구성하는지 알아보겠습니다.    ex)  수식 트리 Expression Tree   수식을 tree형태로 분리한 tree   7 + 4 * 2 -1 를 나타낸 트리는 아래와 같습니다.       Linked List로 Tree 구현  트리는 원하는 방식으로 원하는 모양으로 무궁무진하게 만들 수 있습니다. 단순한 이진 트리를 구현해보겠습니다.      getValue() : 노드에 저장된 데이터 return   setLeftNode() : 왼쪽 노드 세팅   setRightNode() : 우측 노드 세팅   getLetNode(): 좌측 노드 데이터 return   getRightNode(): 우측 노드 데이터 return   inOrderTraversal() : 중위 순회 왼쪽 node -&gt; root node -&gt; 오른쪽 node   preOrderTraversal() : root node -&gt; 왼쪽 node -&gt; 오른쪽 node   postOrderTraversal() : 왼쪽 node -&gt; 오른쪽 node -&gt; root node   public class TreeWithLinkedList&lt;T&gt; {     private T value;     private TreeWithLinkedList&lt;T&gt; leftNode;     private TreeWithLinkedList&lt;T&gt; rightNode;         public TreeWithLinkedList( T value ) {         this.value = value;     }          /**      * left -&gt; root -&gt; right      */     public void inOrderTraversal() {         if( leftNode != null ) leftNode.inOrderTraversal();         System.out.println(value.toString());         if( rightNode != null ) rightNode.inOrderTraversal();     }          /**      * root -&gt; left -&gt; right      */     public void preOrderTraversal() {         System.out.println(value.toString());         if( leftNode != null ) leftNode.preOrderTraversal();         if( rightNode != null ) rightNode.preOrderTraversal();     }      /**      * left -&gt; right -&gt; root      */     public void postOrderTraversal() {         if( leftNode != null ) leftNode.postOrderTraversal();          if( rightNode != null ) rightNode.postOrderTraversal();         System.out.println(value.toString());     }       public T getValue() {         return value;     }      public void setValue(T value) {         this.value = value;     }      public TreeWithLinkedList&lt;T&gt; getLeftNode() {         return leftNode;     }      public void setLeftNode(TreeWithLinkedList&lt;T&gt; leftNode) {         this.leftNode = leftNode;     }      public TreeWithLinkedList&lt;T&gt; getRightNode() {         return rightNode;     }      public void setRightNode(TreeWithLinkedList&lt;T&gt; rightNode) {         this.rightNode = rightNode;     } }   TreeWithLinkedList&lt;Integer&gt; root = new TreeWithLinkedList&lt;Integer&gt;(1); TreeWithLinkedList&lt;Integer&gt; rootLeft = new TreeWithLinkedList&lt;Integer&gt;(2); TreeWithLinkedList&lt;Integer&gt; rootRight = new TreeWithLinkedList&lt;Integer&gt;(3); TreeWithLinkedList&lt;Integer&gt; rootLeftLeft = new TreeWithLinkedList&lt;Integer&gt;(4); TreeWithLinkedList&lt;Integer&gt; rootLeftRight = new TreeWithLinkedList&lt;Integer&gt;(5);  root.setLeftNode(rootLeft); root.setRightNode(rootRight); rootLeft.setLeftNode(rootLeftLeft); rootLeft.setRightNode(rootLeftRight);  root.inOrderTraversal(); // 중위순회 left -&gt; root -&gt; right &gt;&gt; 4 2 5 1 3  root.preOrderTraversal(); // 전위순회 root -&gt; left -&gt; right &gt;&gt; 1 2 4 5 3  root.postOrderTraversal(); // 후위순회 left -&gt; right -&gt; root &gt;&gt; 4 5 2 3 1   배열로 Tree 구현  배열로 2진트리를 구성하려면 우선 배열의 크기를 정해야 하기 때문에 최종 데이터의 크기를 알아야 한다는 점, 왼쪽 노트의 위치, 우측 노드의 위치, 부모 위치 구하는 방법을 알아야합니다.      왼쪽 자식의 index : ( 자기자신의 index ) * 2 +1   오른쪽 자식의 index : 왼쪽 자식의 index + 1 = ( 자기자신의 index ) * 2 +2   부모 index : ( 자기 자신의 index -1 ) / 2   총 크기 : Perfect Binary Tree 크기 만큼 하기 위해, 최종 데이터의 크기를 꽉 찬 트리 size로 만든후 그 크기 * 2 배만큼의 크기가 필요합니다.   public class TreeWithArray&lt;T&gt; {     private Object tree [];     private int treeSize;         public TreeWithArray( int arraySize ) {        treeSize = 1;                  while (treeSize &lt; arraySize) {             treeSize &lt;&lt;= 1;         }         treeSize *= 2;         tree = new Object[ treeSize ];     }          /**      * left -&gt; root -&gt; right      */     public void inOrderTraversal( int checkIndex ) {         if(  checkIndex &lt; treeSize &amp;&amp; tree[checkIndex] != null ) {             int leftChildIndex = getLeftNodeIndex(checkIndex);             int rightChildIndex =  getRightNodeIndex(checkIndex);             inOrderTraversal( leftChildIndex );             System.out.println(tree[checkIndex].toString());             inOrderTraversal( rightChildIndex );         }      }          /**      * root -&gt; left -&gt; right      */     public void preOrderTraversal( int checkIndex ) {         if(  checkIndex &lt; treeSize &amp;&amp; tree[checkIndex] != null ) {             int leftChildIndex = getLeftNodeIndex(checkIndex);             int rightChildIndex =  getRightNodeIndex(checkIndex);             System.out.println(tree[checkIndex].toString());             preOrderTraversal( leftChildIndex );             preOrderTraversal( rightChildIndex );         }      }      /**      * left -&gt; right -&gt; root      */     public void postOrderTraversal( int checkIndex ) {         if(  checkIndex &lt; treeSize &amp;&amp; tree[checkIndex] != null ) {             int leftChildIndex = getLeftNodeIndex(checkIndex);             int rightChildIndex =  getRightNodeIndex(checkIndex);             postOrderTraversal( leftChildIndex );             postOrderTraversal( rightChildIndex );             System.out.println(tree[checkIndex].toString());         }      }       @SuppressWarnings(\"unchecked\")     public T getValue( int index ) {         return (T)tree[index];     }      public void setValue( T value, int index ) {         if( index &gt;= treeSize ) {             throw new IndexOutOfBoundsException(\"size를 확인하세요\");         }         tree[index] = value;     }      @SuppressWarnings(\"unchecked\")     public T getLeftNode( int parentIndex ) {         int childIndex = getLeftNodeIndex(parentIndex);         if( childIndex &gt;= treeSize ) {             throw new IndexOutOfBoundsException(\"size를 확인하세요\");         }         return (T)tree[childIndex];     }      public void setLeftNode( T leftNode, int parentIndex ) {         int childIndex = getLeftNodeIndex( parentIndex );         if( childIndex &gt;= treeSize ) {             throw new IndexOutOfBoundsException(\"size를 확인하세요\");         }         tree[childIndex] = leftNode;     }      @SuppressWarnings(\"unchecked\")     public T getRightNode( int parentIndex ) {         int childIndex =  getRightNodeIndex( parentIndex );         if( childIndex &gt;= treeSize ) {             throw new IndexOutOfBoundsException(\"size를 확인하세요\");         }         return (T)tree[childIndex];     }      public void setRightNode( T rightNode, int parentIndex) {         int childIndex = getRightNodeIndex( parentIndex );         if( childIndex &gt;= treeSize ) {             throw new IndexOutOfBoundsException(\"size를 확인하세요\");         }         tree[childIndex] = rightNode;     }          public int getLeftNodeIndex( int parentIndex ) {         return parentIndex*2 +1;     }          public int getRightNodeIndex( int parentIndex ) {         return parentIndex*2 +2;     } }   TreeWithArray&lt;Integer&gt; tree = new TreeWithArray&lt;Integer&gt;(5); tree.setValue(1, 1); tree.setLeftNode(2, 1); tree.setRightNode(3, 1); tree.setLeftNode(4, tree.getLeftNodeIndex(1)); tree.setRightNode(5, tree.getLeftNodeIndex(1));  tree.inOrderTraversal(1); // 중위순회 left -&gt; root -&gt; right &gt;&gt; 4 2 5 1 3  tree.preOrderTraversal(1); // 전위순회 root -&gt; left -&gt; right &gt;&gt; 1 2 4 5 3  tree.postOrderTraversal(1); // 후위순회 left -&gt; right -&gt; root &gt;&gt; 4 5 2 3 1   그래프     그래프란 위 그림에서 보는 것처럼 노드와 노드를 연결한 간선이 존재하는 자료구조입니다. 이전 자료구조를 공부하면서 봤었던 용어들입니다.      Vertex (정점) : 하나의 노드를 말합니다.   Edge (간선) : 정점을 연결하는 선입니다.   Adjacent vertex ( 인접정점 ) :  자기 자신 정점과 바로 연결된 정점을 말합니다.   Degree ( 차수 ) :  자기 자신과 연결된 간선의 개수를 말합니다.   Cycle : 한 정점에서 시작하여 자기자신으로 끝나는 경로를 말합니다.   오일러 경로 : 그래프에 존재하는 모든 간선을 한 번만 통과하는 것 » 오일러 경로는 차수가 홀수인 정점이 2개일때 존재합니다.   오일러 회로 : 오일러 경로 + 시작점과 끝점이 같은 경우 = 한 붓 그리기 » 차수가 홀수인 정점이 0개일때 오일러 회로가 존재합니다.   방향 그래프  그래프에 방향이 존재하여 G(A,B)는 G(B,A)는 다른 경우를 말합니다.   무방향 그래프  그래프에 방향이 존재하지 않아 양 방향으로 갈 수 있다. G(A,B)는 G(B,A)와 동일한 경우를 말합니다.   가중치 그래프(Weighted Graph)  간선에 비용이나 가중치가 할당된 그래프를 말합니다.   솔직히 업무에서 그래프를 다루거나 사용한 사례는 없어 잘 아는 자료구조는 아닙니다. 단지 백준 알고리즘 혹은 카카오 알고리즘을 풀어 볼 때 관련 내용 등장하면 사용 및 공부하기 위해 정리합니다. 그래프 자료구조를 구현하는 방법은 크게 두 가지가 존재합니다. 하나는 인접 리스트로 구현하는 방법과, 인접행렬로 구현하는 방법입니다.      인접 리스트(Adjacency List)로 구현  내용은 간단합니다. 배열의 index는 자기 자신의 노드 위치를 말하며, 저장된 value는 해당 노드와 연결된 인접 노드를 가리킵니다. 추가로 두 노드 사이의 가중치를 저장하도록 양방향 그래프로 구현해보겠습니다.      push() : 데이터 삽입.   public class GraphArrayList {     private ArrayList&lt;ArrayList&lt;int[]&gt;&gt; graph;          // 정점의 개수로 초기화     public GraphArrayList( int nodeSize ) {         this.graph = new ArrayList&lt;ArrayList&lt;int[]&gt;&gt;();                  // 각각의 정점들 초기화         for( int index=0; index &lt; nodeSize; index++ ) {             graph.add( new ArrayList&lt;int[]&gt;() );         }     }          public void push( int orignalNode, int adjacentNode, int weight ) {         pushOnly( orignalNode, adjacentNode, weight );         pushOnly( adjacentNode, orignalNode, weight );     }          private void pushOnly( int orignalNode, int adjacentNode, int weight ) {         int[] temp = { adjacentNode, weight };         graph.get(orignalNode).add(temp);     }          public void print() {         for (int index = 0; index &lt; graph.size(); index++) {             System.out.println(\"정점 \" + index + \"의 인접리스트\");             for (int indexInner = 0; indexInner &lt; graph.get(index).size(); indexInner++) {                 int[] temp = graph.get(index).get(indexInner);                 System.out.print( temp[0]+\"(\"+temp[1]+\")\" + \" \");             }             System.out.println();         }     } }   GraphArrayList graph = new GraphArrayList(4); graph.push(0, 1, 2); graph.push(1, 2, 7); graph.push(2, 3, 1);  graph.print();   1 2 3 4 5 6 7 8 9 // 출력  정점 0의 인접리스트 1(2)  정점 1의 인접리스트 0(2) 2(7)  정점 2의 인접리스트 1(7) 3(1)  정점 3의 인접리스트 2(1)   인접 행렬(Adjacency Matrix)로 구현  구현 내용은 간단합니다. 2차원 배열에 index가 두 노드의 연결 여부 및 가중치를 나타냅니다. 아래 코드를 보면 이해가 될 것입니다.   public class GraphMatrix {     private int[][] graph;      public GraphMatrix( int nodeSize ) {         graph = new int [nodeSize][nodeSize];     }          public void push( int orignalNode, int adjacentNode, int weight ) {         graph[orignalNode][adjacentNode] = weight;         graph[adjacentNode][orignalNode] = weight;     }          public void print() {         for (int index = 0; index &lt; graph.length; index++) {             System.out.println(\"정점 \" + index + \"의 인접리스트\");             for (int indexInner = 0; indexInner &lt; graph[index].length; indexInner++) {                 if( graph[index][indexInner] &gt; 0) {                     System.out.print( indexInner+\"(\"+graph[index][indexInner]+\")\" + \" \");                 }             }             System.out.println();         }     } }  GraphMatrix graph = new GraphMatrix(4); graph.push(0, 1, 2); graph.push(1, 2, 7); graph.push(2, 3, 1);  graph.print();   1 2 3 4 5 6 7 8 9 //출력  정점 0의 인접리스트 1(2)  정점 1의 인접리스트 0(2) 2(7)  정점 2의 인접리스트 1(7) 3(1)  정점 3의 인접리스트 2(1)     이런 그래프를 일반적으로 탐색하는 방법은 2가지입니다. 하나는 깊이우선탐색(DFS), 다른 하나는 너비 우선 탐색(BFS)입니다.     깊이우선탐색( Depth First Search )  하나의 정점에서 시작하여 다음 인접 노드를 지속해서 확인하여 모든 노드를 탐색하는 방법입니다. 원리는 root노드를 정한 후 인접 노드를 stack에 집어넣고 stack을 순회하면서 호출된 적 있는지 확인 후 반복하는 일만 진행하면 됩니다.   너비우선탐색 ( Breadth First Search )  하나의 정점에서 시작하여 하나의 정점을 완벽히 탐색 후 다음 정점을 넘어가 모든 노드를 탐색하는 방법입니다. 원리는 간단합니다. root노드를 정한 후 root노드에 관련된 인접 노드를 que에 집어넣고 해당 que를 순회하면서 한 번 호출된 적 있는 노드인지 확인 후 que가 빌 때까지 지속하는 방법입니다.   public class GraphMatrix {     private int[][] graph;     private int nodeSize = 0;      public GraphMatrix( int nodeSize ) {         graph = new int [nodeSize][nodeSize];         this.nodeSize = nodeSize;     }          public void push( int orignalNode, int adjacentNode, int weight ) {         graph[orignalNode][adjacentNode] = weight;         graph[adjacentNode][orignalNode] = weight;     }          public void bfs() {         if( nodeSize == 0 ) {             throw new IndexOutOfBoundsException(\" 노드가 비어있습니다.\");         }         int[] cache = new int[nodeSize];         Queue&lt;Integer&gt; nodesQue = new LinkedList&lt;&gt;();         bfsLoopChecking(0, cache, nodesQue);     }          public void dfs() {         if( nodeSize == 0 ) {             throw new IndexOutOfBoundsException(\" 노드가 비어있습니다.\");         }         int[] cache = new int[nodeSize];         Stack&lt;Integer&gt; nodesStack = new Stack&lt;Integer&gt;();         dfsLoopChecking(0, cache, nodesStack);     }          private void bfsLoopChecking( int orignalNode, int[] cache , Queue&lt;Integer&gt; nodesQue ) {         nodesQue.add( orignalNode );         while ( !nodesQue.isEmpty() ) {             Integer nextNodes = nodesQue.poll();             if( cache[nextNodes] == 0 ){                 cache[nextNodes] = 1;                 System.out.println( nextNodes + \" 탐색하였습니다.\");                 for( int childNode = 0; childNode &lt;  graph[nextNodes].length; childNode++ ) {                     if( graph[nextNodes][childNode] != 0 &amp;&amp; cache[childNode] == 0 ) {                         nodesQue.add(childNode);                     }                 }             }         }     }          private void dfsLoopChecking( int orignalNode, int[] cache , Stack&lt;Integer&gt; nodesStack ) {         nodesStack.add( orignalNode );         while ( !nodesStack.isEmpty() ) {             Integer nextNodes = nodesStack.pop();             if( cache[nextNodes] == 0 ){                 cache[nextNodes] = 1;                 System.out.println( nextNodes + \" 탐색하였습니다.\");                 for( int childNode = graph[nextNodes].length -1; childNode &gt; 0; childNode-- ) {                     if( graph[nextNodes][childNode] != 0 &amp;&amp; cache[childNode] == 0 ) {                         nodesStack.add(childNode);                     }                 }             }         }     } }   GraphMatrix graph = new GraphMatrix(5); graph.push(0, 1, 2); graph.push(0, 2, 6); graph.push(0, 4, 6); graph.push(1, 2, 7); graph.push(2, 4, 7); graph.push(2, 3, 1); graph.push(3, 4, 5);  graph.bfs(); // 0 1 2 4 3 graph.dfs(); // 0 1 2 3 4    참고자료     – 윤성우의 열혈 자료구조 ( C언어 )    – 위키백과  ","categories": ["JAVA"],
        "tags": [],
        "url": "https://minesafety-eng.github.io//java/java-dataStructure-2/",
        "teaser":null},{
        "title": "JAVA 알고리즘 1 (Algorithm)",
        "excerpt":"Step 1 : 알고리즘(Algorithm)란 무엇인가?  알고리즘은 어떠한 입력이 있다면 이 입력에 따라 명령을 명확하게 실행하고, 효과적으로 입력에 따른 결과물을 도출할 수 있다면 알고리즘으로 볼 수 있습니다.  즉 특정 원하는 결과를 도출하기 위해 처리하는 의사결정 과정의 코드를 알고리즘이라 칭할 수 있습니다.  알고리즘은 무궁무진하며 지금부터는 이 문제 저 문제 풀어보면서 알게 된 기본적인 알고리즘을 정리하겠습니다.   완전 탐색 ( Brute - Force )  완전 탐색이란 사람이 손으로 하기엔 오래 걸리는 일을 컴퓨터의 힘을 빌려 모든 경우의 수를 계산하여 원하는 결과를 탐색하는 방법입니다. 즉 무식하게 처리하지만 단순하고 강력한 방법이기도 합니다.   재귀 함수  재귀 함수이란 컴퓨터가 수행할 작업 중 반복되는 것을 작업 단위로 쪼개어 한 작업을 실행 후 나머지 작업을 자기 자신에게 호출하는 하여 결과를 완성하는 것을 말합니다. 주로 완전탐색에서 자주 사용되는 방법입니다.   순열 ( Permutation )  순열이란 n 개의 값 중에서 r 개를 순서대로 뽑는 경우를 말합니다. 순열을 풀기 위해서 2가지 방법이 존재합니다.   1)중첩 for문 사용  2)재귀호출 사용해서 구현   ** String n 크기의 배열이 들어 왔을 때, 3개를 순서대로 뽑는 경우의 수를 한번 만들어 보겠습니다.   //ex 123, 124.. String[] people = {\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"}; result(people);   단순 무식하게 중첩루프 사용  풀이는 간단합니다. 중첩 루프를 뽑는 개수만큼 만들고 한번 나왔던 것을 제거하고 도는 것 입니다.  private static void result( String[] people ) {     int count = 0;     for( int firstIndex = 0; firstIndex &lt; people.length; firstIndex++ ) {         for( int secondIndex = 0; secondIndex &lt; people.length; secondIndex++ ) {                          if( firstIndex == secondIndex ) continue;                          for( int thirdIndex = 0; thirdIndex &lt; people.length; thirdIndex++ ) {                 if( thirdIndex == secondIndex || thirdIndex == firstIndex ) continue;                                  String first = people[firstIndex];                 String second= people[secondIndex];                 String third = people[thirdIndex];                 count++;                 System.out.println(\"( \"+first +\" \" + second + \" \" + third +\" )\");             }         }     }     System.out.println(\"총 경우의 수 : \" + count); }    재귀함수로 구현  위로 푼 방법과 유사합니다. 다만 좀 더 코드를 줄일 수 있는 장점이 있습니다. 미리 3개를 뽑는 것이니 크기가 3인 result 배열을 만들어 두고 앞에부터 채워가는데 기존 나왔던 것을 제외하고 채워가는 것입니다.  private static void result( String[] people ) {     int r = 3;     boolean[] isChecked = new boolean[people.length];     String[] result = new String[r];     ArrayList&lt;String[]&gt; totalList = new ArrayList&lt;String[]&gt;();          permutation(people, isChecked, result, r, 0, totalList);          for (String[] strings : totalList) {         String temp = \"\";         for( String text : strings ) {             temp += \" \" + text;         }         System.out.println(temp);     }     System.out.println(\"총 경우의 수 : \" + totalList.size()); }  private static void permutation( String[] people, boolean[] isChecked, String[] result, int endPoint, int dept, ArrayList&lt;String[]&gt; totalList ) {     if( endPoint == dept ) {         totalList.add(result.clone());     } else {         for ( int i = 0; i &lt; people.length; i++ ) {             if( !isChecked[i] ) {                 isChecked[i] = true; // 사용된 배열 위치                 result[dept] = people[i]; // 저장                  permutation(people, isChecked, result, endPoint, dept + 1, totalList);                 isChecked[i] = false; // 사용된 것 다시 제자리                 result[dept] = \"\"; // 저장된 것 제자리             }         }     } }   조합  조합이란 n 개의 값 중에서 r 개를 뽑는 경우를 말합니다.( 123, 321은 같은 것입니다. ) 조합을 풀기 위해서 순열처럼 무식한 방법과 재귀를 이용한 방법이 존재합니다.   중첩 for문 사용  private static void result( String[] people ) {     int count = 0;     for( int firstIndex = 0; firstIndex &lt; people.length; firstIndex++ ) {         for( int secondIndex = firstIndex+1; secondIndex &lt; people.length; secondIndex++ ) {             for( int thirdIndex = secondIndex+1; thirdIndex &lt; people.length; thirdIndex++ ) {                 String first = people[firstIndex];                 String second= people[secondIndex];                 String third = people[thirdIndex];                 count++;                 System.out.println(\"( \"+first +\" \" + second + \" \" + third +\" )\");             }         }     }     System.out.println(count);    }   재귀호출 사용해서 구현  무한 루프에서 한 것을 똑같이 사용하는 것을 단지 재귀로 호출하는 방법입니다. 최종 결과를 저장할 result[]를 만들고 전달하였습니다.  private static void result( String[] people ) {     int end = 3;     int start  = 0;     String[] tempResult = new String[end];     int loopStartIndex = 0;      ArrayList&lt;String[]&gt; result = new ArrayList&lt;String[]&gt;();     combination( people, end, start, tempResult, result, loopStartIndex );     for (String[] strings : result) {         String temp = \"\";         for (String strings2 : strings) {             temp += \" \" + strings2;         }         System.out.println(temp);     }     System.out.println(result.size());      }  private static void combination( String[] people, int end, int start, String[] tempResult, ArrayList&lt;String[]&gt; result, int loopStartIndex ) {     if( end == start ) {         result.add(tempResult.clone());         return;     }          for( int index = loopStartIndex; index &lt; people.length; index++ ) {             tempResult[start] = people[index];             combination(people, end, start+1, tempResult, result, index+1);             tempResult[start] = \"\";     } }    보글게임  보글게임이란 n x n 격자에 한 단어씩 적혀있는 격자가 2차원 배열로 주어질 때, 해당 격자에서 원한는 단어를 찾을 수 있을 때, true를 찾을 수 없을  때 false를 return하는 프로그램입니다. 직관적으로 특정 알고리즘 없이 완전 탐색으로 푼다면, 모든 격자를 시작점으로 인접 8칸에 원하는 단어가  있는지 확인하는 것입니다.    public static void main(String args[]){     String[][] word = {                         {\"N\",\"N\",\"N\",\"N\",\"S\"},                         {\"N\",\"E\",\"E\",\"E\",\"N\"},                         {\"N\",\"E\",\"Y\",\"E\",\"N\"},                         {\"N\",\"E\",\"E\",\"E\",\"N\"},                         {\"N\",\"N\",\"N\",\"N\",\"N\"}                     };      System.out.println(findWord( word, \"YES\" )); }    private static boolean findWord(String[][] word, String findText) {     //1. 종료 조건 현재 위치가 마지막이고, 마지막 단어와 매칭 여부     //2. return 단어 존재 여부 boolean     //3. 한번 온 곳은 다시 가면 안됨.     boolean result = false;     boolean[][] checking = new boolean[word.length][word.length];          out : for (int yIndex = 0; yIndex &lt; word.length; yIndex++) {         for (int xIndex = 0; xIndex &lt; word.length; xIndex++) {             if( result ) {                 break out;             } else {                 result = checking( word, findText, 0, yIndex, xIndex , checking);             }         }     }               return result; }  private static boolean checking(String[][] word, String findText, int checkingIndex, int yIndex, int xIndex, boolean[][] checking) {     boolean result = false;     int[] yCheck = {-1, -1, -1, 0, 0, 1, 1, 1};     int[] xCheck = {-1, 0, 1, -1, 1, -1, 0, 1};          if( yIndex == word.length || yIndex &lt; 0)  return false;     if( yIndex == word.length || yIndex &lt; 0) return false;     if( xIndex == word.length || xIndex &lt; 0) return false;     if( checking[yIndex][xIndex] ) return false;          String checkText = findText.substring(checkingIndex, checkingIndex+1);     String wordText = word[yIndex][xIndex];          if( !checkText.equals(wordText) ) {         return false;     }          if( findText.length()-1 == checkingIndex ) {        return checkText.equals(wordText);     }          // 8방면 검사      for (int cIndex = 0; cIndex &lt; 8; cIndex++) {         checking[yIndex][xIndex] = true;         result = checking(word, findText, checkingIndex+1, yIndex+yCheck[cIndex], xIndex+xCheck[cIndex], checking);         checking[yIndex][xIndex] = false;         if( result ) {             return true;          }     }          return  result; }   소풍  만약 n명의 사람이 소풍을 놀러가서 2명씩 짝을 지어야 하는데, 서로 친구라는 단서가 배열로 주어질 때, 서로 친구인 경우만 짝을 짓는 케이스를 출력하는  프로그램을 짠다고 생각해봅시다.    String[] name = {\"석진\", \"우리\", \"현식\", \"희범\",\"성우\",\"밥\"}; int[][] friend = {{0,1},{0,2},{1,2},{1,3},{1,4},{2,3},{2,4},{3,4},{3,5},{4,5}};  check( name, friend );  완전 탐색을 통해 짝을 짓는 방법은 한명씩 짝을 구성하면서 둘이 친구인 지를 확인하여 친구인 경우만 결과에 추가하는 방법입니다.  짝이 있는 경우는 넘어가면서 다음 짝을 찾는 경우를 찾으면 됩니다.   private static void check(String[] name, int[][] friend) {     // 사람 수와 친구 쌍이 주어졌을 때, 친구끼리 쌍을 짓는 경우의 수 도출     // 2명을 짝을 짓고, 친구인지 확인, 친구인 경우 제거, 나머지로 반복한다. 전체를 다 돌았음에도 짝을 못짓는 경우는 불가능 하다.     // 친구 여부를 확인하기 위한 2차원 boolean 배열 [0][1] = true일 시 둘은 친구이다.      boolean[][] isFriend = new boolean[name.length][name.length];     for( int[] fi : friend ) {         isFriend[fi[0]][fi[1]] = true;         isFriend[fi[1]][fi[0]] = true;     }          // 종료 조건 친구 쌍을 다 찾았을 때 &gt;&gt; 남은 친구가 없을 때 사람수가 0일때.     // return 친구 쌍 조합을 ArrayList     // 확인 여부를 위한 캐쉬     ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;();     boolean[] check = new boolean[name.length];     StringBuilder temp = new StringBuilder();     compair( name.length, result, check, temp, isFriend, name);     System.out.println(result.size()); }  private static void compair( int length, ArrayList&lt;String&gt; result, boolean[] check, StringBuilder temp, boolean[][] isFriend, String[] name) {     if( length == 0 ) {         result.add(temp.toString());         return;     }     int findIndex = 0;     for( int index = 0; index &lt; check.length; index++ ) {         if( !check[index] ) {             findIndex = index;             break;         }     }     // 자기 다음부터 찾아 사전식으로 구성하여 중복을 제거한다.     for( int second = findIndex+1; second &lt; name.length; second++  ) {         if( !check[second] &amp;&amp; isFriend[findIndex][second] ) {             StringBuilder copy = new StringBuilder(temp.toString());             check[findIndex] = true;             check[second] = true;             temp.append(\"( \"+name[findIndex] + \" \");             temp.append(name[second] + \" )\");             compair(length-2, result, check, temp, isFriend, name);             check[findIndex] = false;             check[second] =false;             temp = copy;         }     } }   게임판 덮기  H X W 크기의 2차원 게임판이 있습니다. 게임판이 흰 칸과 검은 칸으로 주어질 때, 세칸짜리 ㄱ모양의 격자로 뒤덮을 수 있는 경우의 수를 출력하는  프로그램을 작성하시오.   public static void main(String args[]){      int[][] image = {                         {1,1,1,1,1,1,1,1,1,1},                         {1,0,0,0,0,0,0,0,0,1},                         {1,0,0,0,0,0,0,0,0,1},                         {1,0,0,0,0,0,0,0,0,1},                         {1,0,0,0,0,0,0,0,0,1},                         {1,0,0,0,0,0,0,0,0,1},                         {1,0,0,0,0,0,0,0,0,1},                         {1,1,1,1,1,1,1,1,1,1}                    };     totalCase( image ); }   private static void totalCase( int[][] image ) {     // 현재 기준점 기준 격채를 변경하면서 채운다.     // 종료조건, 2차원 격자를 돌면서 모두 1인경우.     // return total 1개씩 더해가는 것     System.out.println(check( image )); }  private static int check( int[][] image ) {     int findX = -1;     int findY = -1;     int result = 0;          out : for( int y = 0; y &lt; image.length; y++ ) {         for( int x = 0; x &lt; image[0].length; x++  ) {             if( image[y][x] == 0 ) {                 findY = y;                 findX = x;                 break out;             }         }     }     // 종료조건 : 찾을 곳이 없을 때,     if( findY == -1 ) {         return 1;     }     // 격자 덮기 시작 4방향      for( int loop = 0; loop &lt; 4; loop++ ) {         if( orignalRota(image, findX, findY, loop) ) {             result += check(image);             returnRota(image, findX, findY, loop);         }     }     return result; }  // 복구  private static void returnRota( int[][] image, int x, int y, int type ) {     if( type == 0 ) {         image[y][x] = 0;         image[y][x+1] = 0;         image[y+1][x] = 0;     } else if( type == 1 ) {         image[y][x] = 0;         image[y][x+1] = 0;         image[y+1][x+1] = 0;     } else if( type == 2 ) {         image[y][x] = 0;         image[y+1][x] = 0;         image[y+1][x+1] = 0;     } else if( type == 3 ) {         image[y][x] = 0;         image[y+1][x] = 0;         image[y+1][x-1] = 0;     } }  private static boolean orignalRota( int[][] image , int x, int y, int type ) {     // 현재 기준으로 왼쪽과 위쪽은 다 채워져 있다고 가정. 현재 점 기준으로 ㄱ자 격자를 채울 수 있는 경우는 4가지, 비어있지 않다고 생각하면 경우의 수가 더 많음.     if( ( x+1 ) == image[0].length || ( y+1 ) == image.length || x-1 &lt; 0 ) return false;     boolean result = false;     if( type == 0 &amp;&amp; image[y][x] == 0 &amp;&amp; image[y][x+1] == 0 &amp;&amp; image[y+1][x] == 0) {         result = true;         image[y][x] = 1;         image[y][x+1] = 1;         image[y+1][x] = 1;     } else if(  type == 1 &amp;&amp; image[y][x] == 0 &amp;&amp; image[y][x+1] == 0 &amp;&amp; image[y+1][x+1] == 0) {       //ㄱ 자 1차 회전         result = true;         image[y][x] = 1;         image[y][x+1] = 1;         image[y+1][x+1] = 1;     } else if(type == 2 &amp;&amp;  image[y][x] == 0 &amp;&amp; image[y+1][x] == 0 &amp;&amp; image[y+1][x+1] == 0 ) {         result = true;         image[y][x] = 1;         image[y+1][x] = 1;         image[y+1][x+1] = 1;     } else if( type == 3 &amp;&amp; image[y][x] == 0 &amp;&amp; image[y+1][x] == 0 &amp;&amp; image[y+1][x-1] == 0 ) {       //ㄱ 자 3차 회전         result = true;         image[y][x] = 1;         image[y+1][x] = 1;         image[y+1][x-1] = 1;     }          return result; }   시계 맞추기  예전부터 상상해봤던 문제들 중 하나로 , 1번 ~ 10번 스위치와 각 스위치와 연결된 시계위치가 주어지고, 스위치를 한 번 터치시 연결된 시계가 3시간 이동한다고  할 때, 최소의 스위치를 눌러 모든 시계를 12시로 맞추는 최소 터치 횟수를 구하는 문제입니다. 풀이는 시계라는 것, 즉 터치 4번을  하면 자기 자신의 시간으로 돌아온다는 것을 생각해내야 합니다. 즉 하나의 스위치를 누를 수 있는 최대 경우의 수는 4회입니다. 최대 경우의 수는 4^10  = 1,048,576개로 충분히 작은 숫자이기 때문에 완전 탐색 가능합니다.   // 스위치와 연결된 시계 ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;( Arrays.asList(0,1,2) ); caseTest.add(temp);  temp = new ArrayList&lt;&gt;( Arrays.asList(3,7,9,11) ); caseTest.add(temp);  temp = new ArrayList&lt;&gt;( Arrays.asList(4,10,14,15) ); caseTest.add(temp);  temp = new ArrayList&lt;&gt;( Arrays.asList(0,4,5,6,7) ); caseTest.add(temp);  temp = new ArrayList&lt;&gt;( Arrays.asList(6,7,8,10,12) ); caseTest.add(temp);  temp = new ArrayList&lt;&gt;( Arrays.asList(0,2,14,15) ); caseTest.add(temp);  temp = new ArrayList&lt;&gt;( Arrays.asList(3,14,15) ); caseTest.add(temp);  temp = new ArrayList&lt;&gt;( Arrays.asList(4,5,7,14,15) ); caseTest.add(temp);  temp = new ArrayList&lt;&gt;( Arrays.asList(1,2,3,4,5) ); caseTest.add(temp);  temp = new ArrayList&lt;&gt;( Arrays.asList(3,4,5,9,13) ); caseTest.add(temp);  int[] test = { 12,9,3,12,6,6,9,3,12,9,12,9,12,12,6,6 }; // 16개의 시계가 현재 바라보는 시간 totalCase( test );   private static void totalCase( int[] test ) {     // 케이스 당 4번 , 0,1,2,3     // 종료조건, 모두가 12시인가.     // 종료조건, min보다 클때.     // 종료 조건, 9개를 선택했을 때     int min = 1048577;     min = check( test, 0, 1048577, 0 );     if( min == 1048577 ) {         min = -1;     } }  private static int check( int[] test, int count, int min, int checkNextMin ) {     boolean isFinish = true;     for( int number : test ) {         if( number != 12 ) {             isFinish = false;             break;         }     }     if( isFinish ) {         min = checkNextMin;         return min;     }          if( checkNextMin &gt; min || count == 9 ) {         return min;     }          for( int index = 0; index &lt; 4; index++ ) {         rotate( test, count, index, 1 );         count++;         min = check(test, count, min, checkNextMin+index);         count--;         rotate( test, count, index, -1 );     }          return min;      }   private static void rotate( int[] test, int count, int rotateCount ,int flag ) {     ArrayList&lt;Integer&gt; temp =  caseTest.get(count);     if( flag == 1 ) {         // 정방향 회전         for( Integer item : temp ) {             int clockTime = test[item];             test[item] = (clockTime+3*rotateCount)%12 == 0 ? 12 : (clockTime+3*rotateCount)%12;         }     } else {         // 역방향 회전         for( Integer item : temp ) {             int clockTime = test[item];             test[item] = (clockTime-3*rotateCount) &lt;= 0 ? 12 + (clockTime-3*rotateCount)  : (clockTime-3*rotateCount);         }     } }   참고자료     – 인사이트 - 프로그래밍대회에서 배우는 알고리즘 문제해결 전략( 저자 - 구종만 ) ( C언어 )    ","categories": ["JAVA"],
        "tags": [],
        "url": "https://minesafety-eng.github.io//java/java-algorithm-1/",
        "teaser":null},{
        "title": "JAVA 알고리즘 2 (Algorithm)",
        "excerpt":"분할 정복 ( Divide &amp; Conquer )  분할 정복 알고리즘은 유명한 알고리즘 패턴으로 각개 격파라는 표현을 사용할 수 있습니다.  주어진 문제를 둘 이상의 부분 문제로 나눈 뒤 각 문제에 대한 답을 재귀 호출로 이용해 계산하고,  각 부분의 답으로부터 전체의 해답을 계산하는 방법입니다. 분할 정복 알고리즘들은 대개 세 가지의 구성 요소를 가지고 있습니다.   - 문제를 더 작은 문제로 분할하는 과정 ( divide )   - 각 문제에 대한 답을 원래 문제에 대한 답으로 병합하는 과정 ( merge )  - 더는 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제 ( base case )    분할 정복을 위해서는 몇 가지 특정이 성립해야 합니다. 우선 문제를 둘 이상의 부분 문제로 나누는 자연스러운 방법이 있어야 하고, 부분 문제의 답을 조합해 원래 문제의 답을 계산하는 효율적인 방법이 있어야 합니다.   fastSum(n) = 1+2+3+4+…+n  완전 탐색을 통한 단순 for문으로 해결할 수 있지만, 조금 더 효율적인 알고리즘을 짜보겠습니다.   Divice, Merge : (1+2+3+..+n/2) + ((n/2+1) +(n/2+2)+…+n)  해당 형식으로 분할 한다면 앞쪽은 fastSum(2/n)으로 표시 가능합니다. 두 번째 부분은 a부터 b까지의 합으로 표현되므로 이를 fastSum형식으로 나타 낼 수 있어야 분할이 가능합니다. 해당은 ((n/2+1) +(n/2+2)+…+n) = ((n/2+1) +(n/2+2)+…+(n/2 +n/2) 로 나타낼 수 있기 때문에 결국 n/2 * n/2 + (1+2+3+..+n/2) 으로 가능하기 때문에 최종적으로는 fastSum(n) = fastSum(2/n) + n/2 * n/2 + fastSum(2/n) = 2 X fastSum(2/n) + n^2/4 로 표현 가능합니다. 단 이는 짝수일 때만 가능하기 때문에 홀수 일 때도 따로 처리가 필요합니다.   Base Case : n이 1일때는 따로 계산이 필요없습니다.   private static int fastSum(int n) {     if( n == 1 ) {         return 1;     } else if(n % 2 == 1) {         return fastSum(n-1) + n;     } else {         return 2*fastSum(n/2) + (n*n)/4;     }      }   쿼드 트리 뒤집기  대량의 좌표데이터를 메모리 안에 압축해 저장하기 위해 사용하는 기술 중 Quad Tree란 것이 있습니다. 대표적으로 흑백 그림을 압축해 표현하는 것입니다. 2^n * 2^n 크기의 흑백 그림을 다음과 같은 과정을 거쳐 문자열로 압축하는 것입니다.      그림이 모두 검은색일 경우 압축 결과는 그림 크기와 관계없이 b입니다.   그림이 모두 흰색일 경우 압축 결과는 그림 크기와 관계없이 w입니다.   픽셀이 같은 색이 아니라면 쿼드 트리는 이 그림을 가로세로 각각 2등분해 4개의 조각으로 쪼갠 뒤 각각을 쿼드 트리 압축합니다. 이때 전체 그림의 압축 결과는 x(왼쪽 위 압축결과)(오른쪽위 압축 결과)(왼쪽 아래 압축결과)(오른쪽 아래 압축결과)   만약 전체 그림의 압축 결과가 xxwww bxwxw bbbww xxxww bbww wwbb가 주어졌을 때 이 그림을 상하로 뒤집은 그림을 쿼드 트리 압축해서 출력하는 프로그램을 작성하시오.   가장 무식한 방법은 그림을 다시 원래대로 만들고, 상하 반전, 쿼드트리압축 과정을 수행하는 것입니다. 다만 입력이 특정 이상이 될 경우 해당 방법은 사용할 수 없습니다. 이에 우리는 두 가지의 접근 방법을 생각해야 합니다.      큰 입력에도 동작하는 효율적인 알고리즘을 처음부터 새로 만들기   작은 입력에 대해서만 동작하는 알고리즘으로부터 시작해 최적화해 나가기.   둘 중 어느 접근이 맞는지 판단하기는 쉽지 않습니다. 하지만 접근하기 쉬운 방법은 두 번째 방법으로 단순한 알고리즘으로 시작해 최적화해 가는 것입니다.     우선 가장 중요한 쿼드트리의 압축을 어떻게 풀어나가야 하는지 알아보겠습니다.  쿼드트리 자체가 재귀적으로 구성되어 있기 때문에 트리를 압축하거나 해제하는 과정 또한 재귀 호출로 정의하는 것이 자연스럽습니다.  압축을 해제하여 n * n의 이미지로 복구하는 decompress() 함수입니다. ( n은 주어졌다고 가정해야 해제할 수 있습니다. 예제는 16 * 16 이미지를 복구하는 것으로 하겠습니다. )   private static int inputIndex = 0;      public static void main(String args[]){     quardTreeDraw(\"xxwwwbxwxwbbbwwxxxwwbbbwwwwbb\", 16);      }  private static void quardTreeDraw( String input , int n) {     String[][] xy = new String[n][n];     decompress(0, 0, n, input, xy );     String result = \"\";     for( int yindex = 0; yindex &lt; n; yindex++ ) {         for( int xIndex = 0; xIndex&lt; n; xIndex++ ) {             result += xy[yindex][xIndex] + \" \";         }         result +=\"\\n\";     }     System.out.println(result);      }  private static void decompress( int x, int y, int n, String input, String[][] xy) {     char inputItem = input.charAt(inputIndex++);     if( inputItem == 'w' ) {         for( int yIndex = 0; yIndex &lt; n; yIndex++ ) {             for( int xIndex = 0; xIndex &lt; n; xIndex++ ) {                 xy[y + yIndex][ x + xIndex] = \"-\";             }         }     } else if( inputItem == 'b' ) {         for( int yIndex = 0; yIndex &lt; n; yIndex++ ) {             for( int xIndex = 0; xIndex &lt; n; xIndex++ ) {                 xy[y + yIndex][ x + xIndex] = \"+\";             }         }     } else {         int half = n/2;         decompress( x, y, half, input, xy );// 좌상.         decompress( x+half, y, half, input, xy );// 우상.         decompress( x, y+half, half, input, xy );// 좌하.         decompress( x+half, y+half, half, input, xy );// 우하.     } }   이제 근본적으로 문제를 풀어봅시다. 재귀를 이용하는 것은 확실하며, 단순히 원하는 것은 뒤집은 그림입니다.  ‘뒤집다’의 개념은 위아래가 바뀌는 것입니다. 즉 4등분으로 나누었을 때, 상하가 바뀌는 것이며, w, b일 때는 뒤집지 뒤집을 필요가 없어서 그대로를 return 하는 것입니다.  즉 작은 문제로 분할 ( 4등분 한다. ) , 병합과정, base case를 코드로 표현하면 아래와 같습니다.   private static int inputIndex = 0;  public static void main(String args[]){     quardTreeRevers(\"xxwwwbxwxwbbbwwxxxwwbbbwwwwbb\", 16);      }  private static void quardTreeRevers( String input , int n) {     String result = revers( input );     System.out.println(result);      }  private static String revers( String input ) {     char inputItem = input.charAt(inputIndex++);     if( inputItem == 'w' || inputItem == 'b' ) {         return String.valueOf(inputItem);     } else {         String leftUp = revers(input);         String rightUp = revers(input);         String leftDown = revers(input);         String rightDown = revers(input);                  return \"x\" + leftDown + rightDown + leftUp + rightUp;     } }   울타리 잘라내기  너비가 같은 일정한 울타리가 있습니다. 시간이 지남에 따라 판자들이 부서지거나 망가져 높이가 불규칙적으로 변한 관계로 울타리를 통째로 교체하기로 했습니다.  이 때, 버리는 울타리의 일부를 직사각형으로 잘라 재활용 하고 싶습니다. 만약 input으로 fence의 높이가 배열로 주어질 때, 최대로 재활용 할  수 있는 fence의 크기를 계산하는 알고리즘을 도출하시오. 단 아래 이미지의 3번째 처럼 대각선은 불가능 합니다. ( input의 최대 크기는 20000개 )      완전탐색  만약 완전 탐색으로 문제를 푼다면, 기둥 하나를 처음부터 끝가지 잘라서 매치 해보는 것입니다.   private static int maxIndex = 0;      public static void main(String args[]){     int[] input = {1,4,4,4,4,1,1}; // 결과 16     System.out.println(maxFence(input)); }  private static int maxFence(int[] input) {     int result = 0;     maxIndex = input.length;     for( int left = 0; left &lt; maxIndex; left++ ) {         int minHeight = input[left];         for( int right = left; right &lt; maxIndex; right++ ) {             minHeight = Math.min(minHeight, input[right]);             result = Math.max(result, minHeight*(right - left +1 ));         }     }          return result; }   해당 방법은 2중 for문으로 인해 input의 최대 크기가 20000개 이기 때문에 20000*20000 4억번의 연산이 필요해 통과하기 어려울 수  있습니다.   분할정복  만약 이 문제를 분할정복으로 푼다면 어떻게 풀 수 있을까요? 최대 넓이를 찾는다를 기준으로 중간을 기점으로 왼쪽 영역의 최대, 오른쪽 영역의 최대로 나누어  회귀를 적용한다면 속도가 어마하게 빨라질 것 같습니다. 단. 걸쳐있을 때도 가정해야 합니다. 걸쳐있을 때는 걸쳐있는 모든 경우의 max를 비교하여 찾으면  됩니다. 아래 이미지 처럼 2개로 시작하여, 왼쪽 오른쪽을 비교하여 더 큰 막대기쪽으로 작은것 기준으로 넓혀가면서 면적을 비교하는 것입니다.       private static int maxIndex = 0; private static int[] inputData;  public static void main(String args[]){     int[] input = {1,4,4,4,4,1,1}; // 결과 16     System.out.println(maxFence(input)); }  private static int maxFence(int[] input) {     inputData = input;     maxIndex = input.length-1;     return solve( 0, maxIndex ); }  private static int solve( int start, int end ) {     if( start == end ) {         return inputData[start];     } else {         int mid = ( start + end )/2;         int leftMax = solve( start, mid );         int rightMax = solve( mid+1, end );         int result = Math.max(leftMax, rightMax);                  int leftCheck = mid;         int rightCheck = mid+1;                  int height =  Math.min(inputData[leftCheck], inputData[rightCheck]);         result = Math.max(result, height*2); // 중앙에 걸쳐있는 2개가 최대인 경우 확인.                  while( start &lt; leftCheck || rightCheck &lt; end  ) {             if( rightCheck &lt; end &amp;&amp; ( leftCheck == start || inputData[leftCheck-1] &lt; inputData[rightCheck+1] ) ) {                 rightCheck++;                 height = Math.min(height, inputData[rightCheck]);                 // 우측으로 확장해야하는 케이스 외 모두 좌측 확장                 // 왼쪽이 끝났거나, 왼쪽보다 오른쪽 막대가 더 커서 우측으로 자를 수 있을 때.             } else {                 leftCheck--;                 height = Math.min(height, inputData[leftCheck]);             }                          result = Math.max(result, (rightCheck-leftCheck+1)*height); // 좌 우 확장해 나가면서 확인         }                  return result;              }      }    해당 방법은 중간에 1/2씩 나누어 집니다. 결국 O(logN)과 내부적으로 중간 확인을 위한 N번씩 반복이 존재함으로 O(NlogN) 즉 대략 29만번의 연산이면 해답을  구할 수 있어 시간내에 충분히 풀 수 있습니다.   참고자료     – 인사이트 - 프로그래밍대회에서 배우는 알고리즘 문제해결 전략( 저자 - 구종만 ) ( C언어 )    ","categories": ["JAVA"],
        "tags": [],
        "url": "https://minesafety-eng.github.io//java/java-algorithm-2/",
        "teaser":null},{
        "title": "Javascript ECMAScript6( ES6 - 이크마6 )",
        "excerpt":"최근 Node.js를 공부하면서 Front-End 개발에 높은 가능성과 흥미를 느끼게 되어 front-end 개발자가 되기 위한 첫 관문인 ES6 문법에 대해 한번 정리하는 게시물을 작성하고자 합니다. 주안점은 javascript 문법을 공부하는 포스트는 아니고 개인적으로 몰랐던 부분을 정리하는 포스트입니다.   빌트인(Built-in) 오브젝트 : 자바스크립트 엔진이 랜더링 시 미리 생성하는 것으로 개발자가 사전처리 하지 않아도 바로 사용할 수 있는 object입니다.  Function, Object, Array, Number, String 등의 오브젝트가 이에 속합니다.    var, let, const  변수를 설정하는 방법에는 크게 3가지 선언문이 존재합니다. ES6 이전에 존재하였던 var과 ES6에 등장한 let, cont 변수에  관해 한번 차이점을  비교해보겠습니다.   var  var의 경우는 ES6 이전의 문법으로 매우 유연한 방식의 변수 선언 방법입니다. var의 경우는 let, cont와 다르게 블럭 단위 scope가  아닌 함수 단위 scope입니다. 때문에 if {} 해당 블럭내부에 선언되나, 밖에 선언되나 같은 scope입니다. 이 외 javascript 변수에  관한 특징들은 나열하지 않겠습니다.   테스트 1  var test = \"test1\"; function temp(){     var test = \"test2\";     console.log(test); }  temp(); console.log(test);   1 2 test2 test1   테스트 2  var test = \"test1\"; if( true  ){     var test = \"test2\";     console.log(test); }  console.log(test);   1 2 test2 test2   let  let은 var과 다르게  블록 scope({}) 변수입니다.   let test = \"test1\"; if( true  ){     let test = \"test2\";     console.log(test); }  console.log(test);   1 2 test2 test1   var과 다르게 호이스팅이 일어나지 않습니다. Hosting이란 우리가 사용하는 모든 변수들의 선언만  유효범위 최 상단에 위치하도록 눈에 보이지 않지만  내부적으로 끌어올려 동작하도록 돌아갑니다.   console.log(test); // 변수가 없음에도 undefined입니다. console.log(test2); // 변수가 없어 에러가 발생합니다. var test = 1;   해당 예제에서 test가 에러 없이 동작하는 이유는 하단 var test = 1; 부분이 존재하기 때문에 javascript parser가 코드를 재정리  할 때 var test; 부분을 코드 맨 위로 끌어올리기 때문에 undefined가 발생하게 되는 것입니다.        let은 window 객체에 추가되지 않습니다. 때문에 this.{변수명}을 통해 접근할 수 없습니다.   var test = 1; let test2 = 2; console.log(this.test); // 1 console.log(window.test); // 1 console.log(this.test2); // undefined console.log(window.test2); // undefined   const  let과 모든 특징을 같이 합니다. 다만 let은 변수에 할당된 값을 변경할 수 있지만 const는 한번 할당된 값을 변경하려고 하면 에러가 발생됩니다.   let test = 1; const test2 = 2; test = 2;  console.log(test); //2   test2 = 3; // Uncaught TypeError: Assignment to constant variable 에러 발생  console.log(test2); // 진행 안됨    arrow 함수  쉽게 설명해서 기존 function(){} 으로 함수를 선언하던 것을 =&gt;를 통해 편리하게 사용할 수 있도록 한 것입니다.   // 기존 방식 const tempFun = function( param1, param2 ){     console.log(param1,param2); }  const tempFunsum = function( param1, param2 ){     return param1 + param2; }   // 화살표 함수 사용 const tempFun2 = ( param1, param2 ) =&gt; console.log( param1, param2); const tempFunsum2 = (param1, param2) =&gt; param1 + param2   tempFun(\"안\",\"녕하세요\"); // 안 녕하세요 출력 tempFun2(\"안\",\"녕하세요\"); // 안 녕하세요 출력 console.log(tempFunsum(1,2)); // 3 console.log(tempFunsum2(1,2)); // 3   코드가 2줄이 넘어간다면 블록을 통해 표현하면 됩니다.   const tempFun2 = ( param1, param2 ) =&gt; {     console.log( param1, param2);     console.log( param2, param1); }  tempFun2(\"안\",\"녕하세요\");  만약 단순 object를 리터럴 형식으로 return 할 경우 아래와 같은 방식으로 해야합니다.   const tempFun = ( param1, param2 ) =&gt; ({'성':param1, '이름' : param2});  console.log(tempFun(\"김\",\"석진\")); // {성: \"김\", 이름: \"석진\"}   화살표 함수 내부에서는 arguments 프로퍼티를 사용할 수 없고 대신 rest파라미터를 사용합니다. ( …rest rest파라메터라고 부르며 뒤에  나옵니다. )   const tempFun = function (){     console.log ( arguments ); }  const tempFun2 = () =&gt; {     console.log ( arguments ); }  const tempFun3 = (...rest) =&gt; {     console.log ( rest ); }  tempFun(\"김\",\"석진\"); //Arguments(2)...; tempFun3(\"김\",\"석진\"); //  [\"김\", \"석진\"] tempFun2(\"김\",\"석진\"); // arguments is not defined  화살표 함수 내부의 this는 Lexical this로 실행 시간에 정해지는 것이 아닌 정적으로 상위 스코프로 고정됩니다.   function MakeName ( fistName, SecendName ){     this.fistName = fistName;     this.SecendName = SecendName; }  MakeName.prototype.getName = function(){     setTimeout(function(){         console.log(this);         console.log(this.fistName,this.SecendName);     }, 1000); }  MakeName.prototype.getName2 = function(){     setTimeout(() =&gt; {         console.log(this);         console.log(this.fistName,this.SecendName);     }, 1000); }  const myName = new MakeName(\"김\",\"석진\"); myName.getName(); // Window 객체, this.fistName은 undifined 떨어집니다. myName.getName2(); // MakeName 객체, 김 석진 출력  Iteration  Iteration은 반복처리를 나타내며, 반복 처리를 위한 규약인 프로토콜을 가지고 있습니다. 이터레이션 프로토콜은 Iterable 프로토콜과 Iterator  프로토콜로 구성 됩니다.   Iterable 프로토콜  이터러블 프로토콜은 오브젝트의 반복 처리를 어떻게 해아하는지에 대한 규약을 정의하며 String, Array, Map, Set, TypedArray,  Argument 빌트인 오브젝트는 이런 이터러블 프로토콜을 가지고 있습니다. 또한 DOM의 NodeList도 가지고 있습니다. 이런 오브젝트들은 js엔진이  랜던링될 때 이터러블 프로토콜을 설정하기 때문에 따로 사용자가 사전처리를 하지 않아도 반복 처리를 할 수 있습니다. 이런 이터러블 프로토콜이 설정된 오브젝트를  이터러블 오브젝트라고 합니다. 자바스크립트는 이터러블 오브젝트에 Symbol.iterator가 있어야 합니다. 즉 위와 같은 빌트인 객체를 상속받는 것이 아닌  개별 객체를 만들고 해당 객체를 이터러블 객체로 만들기 위해서는 Symbol.iterator를 추가하고 Symbol.iterator에 반복 처리를 할  수 있는 코드를 작성하면 됩니다.   Iterator 프로토콜  이터레이터 프로토콜은 오브젝트의 값을 차례대로 어떻게 처리해야하는 지에 대한 규약입니다. 잘 처리되어 있다면 Symbol.iterator().next() 를  통해 차례로 값을 가져올 수 있습니다.   Spread 연산자(…)  스프레드 연산자는 위에서 설명한 이터러블 오브젝트의 엘리먼트를 하나씩 분리하여 전개합니다. 즉 풀어서 세팅한다는 개념으로 접근하면 됩니다.   const first = [1,2]; const second = [5,6]; const union = [0, ...first, 4, ...second ]; // 1,2 , 5, 6을 풀어서 세팅  console.log( union ); //[0, 1, 2, 4, 5, 6]  const myname = \"김석진\";  console.log([...myname]);  // [\"김\", \"석\", \"진\"] console.log(...myname); // 김 석 진  function paramChect ( one, two ){     console.log( one, two ); }  paramChect( ...union ) // 1 2 &gt;&gt; 호출하는 함수의 파라미터 값을 spread 연산자로 작성하면 함수를 호출하기 전 파라메터 값을 분리해서 전개합니다.    rest 파라미터  함수의 파라메터로 Spread 연산자를 작성한 형태를 rest 파라미터라고 부릅니다. 코드로 확인하는 것이 직관적이라 코드롤 보시면 무난하게 이해 되  실 것입니다. 꼭 호출하는 쪽도 spread 연산자를 통해서 호출해야 정상 동작됩니다.   const first = [1,2]; const second = [5,6]; const union = [0, ...first, 4, ...second ];  function restParameter1(...rest ){     console.log(rest); }  function restParameter2( one, two, ...rest ){     console.log(one);     console.log(two);     console.log(rest); }  restParameter1(...union); restParameter2(...union);   1 2 3 4 5 (6) [0, 1, 2, 4, 5, 6]  0 1 (4) [2, 4, 5, 6]   Array-like  Array는 아니지만 Object르 Array처럼 사용할 수 있도록 한 Object를 Array-like라고 합니다.      배열은 index를 가지고 있다.   배열은 length를 통해 엘리먼트의 수를 확인할 수 있다.   해당 특징을 만족하는 형태가 Array-like입니다.   const arrayLike = {     0 : 'test1',     1 : 'test2',     length : 2 }  for( let index = 0; index &lt; arrayLike.length; index++ ){     console.log(arrayLike[index]); }   // test1 test2 출력    Destructuring - 디스트럭처링  오른쪽에 있는 것을 분해하여 왼쪽에 할당하는 것을 디스럭처링이라고 말합니다. 배열과 객체 2개 다 가능합니다.   Array 분할 할당  Array를 분할 할당하는 예제입니다.   let one, two, three, four, five; const val = [4,5,6,[1,2]];  [ one, two, three ] = [ 1,2,3 ]; console.log( one, two, three); // 1 2 3  [ one, two, three,[ four ,five ] ] = val; console.log( one, two, three, four, five); // 4 5 6 1 2  let others = []; [ one, ...ohers] = [ 1, 2, 3, 4];  console.log(one, ohers); //1 (3) [2, 3, 4]   Object 분할 할당  Object를 분할 할당하는 예제입니다. Object를 프로퍼티 단위로 분할하고 프로퍼티 키와 이름이 같은 왼쪽 변수에 값을 할당합니다. 좌측에도 { key : value}  형식이라면, value가 변수가 됩니다. 사전에 선언된 변수를 사용하려면 ()로 감싸주어야 합니다. 혹은 var, let, const를 통해 바로 초기화 할 수 있습니다.   let one, two, three, four, five;  ({ one, two, three } = { one : 1 , two: 2, three : 3 }); console.log( one, two, three); // 1 2 3  let { first, second }  = { first : 1, second : 2}; console.log(first, second); // 1 2  let third, fourth; ({ one : third, two : fourth } = { one : 3, two : 4}) console.log( third, fourth); // 3 4  let { one : seventh, two : eighth } = { one : 7, two : 8}; console.log( seventh, eighth); // 7 8  // 파라메터 function temp ( { one, two, three : { four : five } } ){     console.log( one, two, five );  }  temp( { one : 1, two : 2, three : { four : 5} } ); //1 2 5  Operation - 오퍼레이션  프로퍼트 이름 조합  문자열 + 변수를 조합하여 object의 프로퍼티 명으로 사용 가능합니다. 조합하려는 이름을 [] 안에 적습니다.   const temp = \"hi_\"; const destructure = \"sport\"; const obj = {     [\"one\" + \"two\"] : 12,     [temp + \"name\"] : \"hihi\" } const { [destructure] : value , palyer = \"박지성\" } =  { sport : \"축구\" }; const { [destructure] : value2 , palyer2 = \"하..\" } =  { sport : \"농구\", palyer2 : \"누구지..\" };  console.log(obj.onetwo); // 12 console.log(obj.hi_name); // hihi console.log(value); // 축구 console.log(palyer); // 박지성 console.log(palyer2); // 누구지..   for - of  위에서 설명한 이터러블 오브젝트를 반복하여 처리합니다. for - in 문과의 차이는 for in문의 경우 대상은 Object이며 열거가능한 프로퍼티가 대상입니다.   const values = [     {item : \"연봉\", amount : { month : 12, year : 1000 }},     {item : \"나이\", amount : { month : 12, year : 1 }} ]  for ( let item of [10,20,30]){     console.log(item); // 10, 20, 30 출력 }  for ( let item of \"김석진\"){     console.log(item); // 김, 석, 진 출력 }  for ( let { item , amount : { month : monthValue, year : yearValue  } } of values ){     console.log(item, monthValue, yearValue); // 연봉 12 1000 , index.html:32 나이 12 1 출력 }  for ( let item of {a : 1, b : 2}){     console.log(item); //Uncaught TypeError: {(intermediate value)(intermediate value)} is not iterable 에러 발생 }  Object  es6에서 추가된 부분을 살펴보겠습니다.   오퍼레이션  변수 이름을 사용하여 Object의 프로퍼티를 설정할 수 있습니다. 함수이름도 생략 가능합니다.   const one = 1; const two = 2; const obj = {     one,     two,     getTemp(){         return 100;     } }  console.log( obj.one, obj.two, obj.getTemp()); // 1 2 100    디스크립터 getter, setter도 사용하기 쉽게 변경되었습니다.   const one = 1; const two = 2; const obj = {     baseCost : 100,     get val(){         return this._val;     },     set val( param ){         this._val = this._val != undefined ? this._val + param : param;     } } obj.val = 100; obj.val = 100; obj.val = 100; obj.val = 100; console.log( obj.val ); // 400   Template 리터럴  문자열 처리를 위한 템플릿을 제공합니다. 사용법은 간단합니다. 특정 부분이 변수로 치환된다고 보시면 됩니다. 코드를 보시면 이해가 되실 것입니다.  let nation = '한국';  console.log(`우리 나라는 ${nation} 입니다.`); // 우리 나라는 한국입니다.  nation = '미국' console.log(`우리 나라는 ${nation} 입니다.`); // 우리 나라는 미국입니다.   탬플릿 앞에 tag할 함수를 작성한 형태를 tagged 탬플릿이라고 합니다. 함수를 호출하기 전 문자열과 표현식을 분리시켜 파라메터로 넘겨줍니다.   let one = 1; let two = 2; function temp ( textArray , plus, minus ){     console.log(textArray[0], plus, textArray[1], minus, textArray[2]); // 2 + 1 =  3 입니다. 2 - 1 =  1 입니다. }  temp `2 + 1 = ${one + two}입니다. 2 - 1 = ${two - one}입니다.`;  Generator 오브젝트  function* 와 같은 키워드를 사용한 함수를 제너레이터 함수라고 표현하며 일반적으로 함수를 호출한다면 함수 블록이 1회 실행되지만, 제네레이터  오브젝트를 생성하여 반환 후 나누어서 실행할 수 있게 합니다. 생성된 제너레이터는 이터레이터 오브젝트이기 때문에 나누어서 실행 가능합니다. yield  키워드 단위로 나누어서 실행합니다.    function* test( one, two ){     let tepm = 0;     console.log(tepm); // 0     tepm += one + two;     tepm += yield tepm;     /*         첫 yield 전 까지 실행하고  멈춤니다.          실행 범위는                   let tepm = 0;         console.log(tepm); // 0         tepm += one + two;         tepm += yield                  입니다.          yield 우측 tepm이 retrun 값입니다. {value: 3, done: false}     */           console.log(tepm); // 1003     tepm += one + two;     yield tepm + one + two + 11;     /*         두번째 yield 전 까지 실행하고  멈춤니다.          실행 범위는                   tepm += yield tepm; &gt;&gt;&gt; tepm는 retun하여 사라지고, 들어온 파라메터 값이 yield에 치환됩니다.                  console.log(tepm); // 3         tepm += one + two;                           입니다.          yield 우측 tepm + one + two + 11; 값을 리턴합니다. {value: 1020, done: false}     */      console.log(tepm); // 1006     yield { 'result' : tepm + '입니다.'};      /*         세번째 yield 전 까지 실행하고  멈춤니다.          실행 범위는                   console.log(tepm);                  입니다.          yield 우측  { 'result' : tepm + '입니다.'} 값을 리턴합니다. {value: {result: \"106입니다.\"}, done: false}     */      return tepm; }  let getObj = test(1,2);  console.log(getObj); // Generator를 반환합니다. console.log( getObj.next() ); // 첫번째 {value: 3, done: false} console.log( getObj.next(1000) ); //두번째  {value: 1020, done: false} console.log( getObj.next() ); // 세번째 {value: {result: \"106입니다.\"}, done: false} console.log( getObj.next() ); // 더 이상 yield가 없기 때문에 최종 return을 반환합니다. {value: 1006, done: true}    .return(param)을 통해 이터레이터를 종료 시킬 수 있습니다.   function* test(){     let temp = 0;     while( true ){         console.log(temp);         temp += yield temp;     }  }  getObj = test(); console.log( getObj.next()); // {value: 0, done: false} console.log( getObj.next(10)); // {value: 10, done: false} console.log( getObj.next(100)); // {value: 110, done: false} console.log( getObj.return(1000)); // {value: 1000, done: true} console.log( getObj.next()); // {value: undefined, done: true} console.log( getObj.next()); // {value: undefined, done: true}   yield* [배열] 을 통해 next로 받아올 인자를 미리 정할 수도 있습니다.   function* test(){     while( true ){         yield* [1,2,3]     }  }  getObj = test(); console.log( getObj.next()); // {value: 1, done: false} console.log( getObj.next()); // {value: 2, done: false} console.log( getObj.next()); // {value: 3, done: false} console.log( getObj.next()); // {value: 1, done: false}   Class 오브젝트  JAVA와 같은 객체지향 언어처럼 문법을 구현할 수 있도록 제공해주는 객체입니다.   class Member {     static TEMP_NAME =\"hihi\";      constructor( name, age ) {         this.name = name;         this.age = age;     }          // getter     get getName(){         return this._name;     }     // setter      set setName( name ){         this._name = name;     }      // getter     get age(){         return this._age;     }     // setter      set age( age ){         this._age = age;     }      toString(){         console.log( `${Member.TEMP_NAME} 난 ${this.name}이고 ${this.age}살 이야` )     }     getLeader(){         console.log(\"리더 취득\");     }  }  class Soccer extends Member {     constructor( name, age, part ){         super(name, age);         this.part = part;     }      toString(){         super.toString();         console.log( `파트는 ${this.part}야` )     }     getData(){         console.log(\"데이터 취득\");     }  }  const soccer = new Soccer(\"김석진\", \"8\", \"유소년 축구팀\" ); soccer.toString(); soccer.getLeader(); soccer.getData();   1 2 3 4 hihi 난 김석진이고 8살 이야 파트는 유소년 축구팀야 리더 취득 데이터 취득   Symbol 오브젝트  es5에서는 primitive 타입에 null, string, number, undefined, boolean 5개가 있었지만 es6에서는 symbol이  추가되었습니다. Wrapper 클래스는 Symbol 오브젝트입니다. Symbol을 통해 생성된 값은 프로그램 전체를 통해 유일하며 개발자 도구에서도 그  값을 볼 수 없습니다.   var temp = Symbol(); console.log(temp); // Symbol()   유일한 값을 갖는 symbol의 특징을 이용하여 object의 키로 사용할 수 있습니다. [] 안에 변수를 집어넣는 의미는 symbol-keyed property임을  명시하는 것입니다. 즉 심볼값은 문자열이 아님을 명시하는 것과 비슷합니다.   const temp = Symbol(\"123\"); obj = {     [temp] : 'ppppp' }  console.log(obj[temp]) // ppppp  Symbol은 Enumerale이 false이기 떄문에 for-in문을 통해 출력되지 않습니다. 이외의 Symbol 메서드와 Symbol 프로퍼티에 관해서는 정리하지 않겠습니다.   Map 오브젝트  Map 오브젝트의 특징은 Objec의 경우 키 값이 String과 Symbol만이 가능하지만 Map은 Object, Function과 같은 오브젝트도  키가 될 수 있습니다. 또한 key는 추가한 순서대로 읽힌다는 특징이 있습니다. Map을 생성할 때 파라메터는 이터러블 오브젝트이어야 합니다. 이터러블  오브젝트를 작성하고 그 안에 배열로 [key,value]를 작성해야 합니다.  const emptMap = new Map([     [\"key1\",\"value1\"],     [\"key4\",\"value4\"],     [\"key2\",\"value2\"],     [\"key3\",\"value3\"] ]);  emptMap.set(temp, temp);  function temp(){     console.log(\"temp\"); } console.log(emptMap.get(\"key1\")) //value1 emptMap.get(temp)() //temp  for( const [ key, value ] of emptMap ){     console.log( emptMap.get(key) ); // 1-&gt; 4 -&gt; 2 -&gt; 3 - &gt; temp 순서가 보장된다. }  WeakMap 오브젝트  Map 오브젝트의 key에 오브젝트만 지정할 수 있으며, string, number, symbol과 같은 값을 작성할 수 없습니다. Weakmap의 장점은 느슨한  연결 때문에 Weakmap을 사용하는 객체 또한 GC대상이 됩니다.   let temp = { temp: \"aaa\" }; let temp2 = [temp];  temp = null; // 지웠음에도   setTimeout(() =&gt; {     console.log(temp2); // 존재  }, 10000);    let temp = { temp: \"aaa\" }; const emptMap = new WeakMap([     [{ temp: \"aaa\" },\"오브젝트\"] ]);  temp = null;  setTimeout(() =&gt; {     console.log(emptMap); // 제거됨 }, 10000);  Set, WeeakSet 오브젝트  Set은 java의 Set과 기능이 같습니다. WeakSet은 WeakMap처럼 value로 object만 가능합니다.   const temp = new Set([1,2,3,3,3,3,3,\"스포츠\"]); console.log(temp) // {1, 2, 3, \"스포츠\"}   Proxy 오브젝트  Proxy의 사전적인 의미는 “대리”입니다. 즉 프록시는 메서드의 기본적인 오퍼레이션과 행위를 중간에 가로채어 대신 일련의 처리를 하는것을 말하니다.  주로 setter, getter, construct 등등 빌트인 오브젝트에 내부 메서드들에 대해 중간에 가로 채 특정 부분을 추가할 수 있습니다. 사용법은  new Proxy( target , 실행할 handler ); 입니다. 그럼 object에 키와 value를 추가할 때 set 트랩과, get 트랩을  이용하여 특정 행위를 제어하는 코드를 작성해 보겠습니다. 아래 외 다양한 것들이 존재하니 필요시 추가로 포스트 하겠습니다.   const obj = {     'name' : '김석진',     'job' : '개발자' }  const handler1 = {     set( target, key, value, receiver ){         // set 트랩은 총 4개의 파라메터를 가질 수 있습니다.         // 1. target, 2. 프로퍼티 key, 3. 프로퍼티 value, 4. set이 포함된 Proxy 인스턴스 receiver ( 사용하지 않는 경우도 많음 )         if( key === 'age' ){             if( !Number.isInteger(value) ){                 value = parseInt(value) + 100;             }         }          target[key] = value;     },     get( target, key, receiver ){            // get 트랩은 총 3개의 파라메터를 가질 수 있습니다. setter와 동일합니다.         if( key === 'age' ){             return `나이는 ${target[key]} 입니다.`         }     } }  const obj_proxy = new Proxy( obj, handler1 );  obj_proxy.age = '10'; console.log( obj_proxy.age ); // 나이는 110 입니다.   Reflect 오브젝트  Reflect 오브젝트의 모든 메서드는 static 메서드이기 때문에 바로 호출할 수 있습니다. Proxy 오브젝트의 모든 트랩 메서드는 Reflect도  가지고 있습니다. 실질적으로 Reflect를 사용하는 의미에 대한 부분이 정확히 이해가 되지 않아 Reflect가 있다라는 정도만 하고 넘어가겠습니다.   Promise  자바스크립트는 싱글스레드 동기( Synchronous ) 방식으로 실행하기 때문에 첫 줄이 완료되어야 두번째 줄이 실행됩니다. 하지만 통신과 같은 경우  비동기로 처리가 되어야 하기 때문에 비동기 상황에서의 컨트롤을 하기 위해 존재합니다. 만약 아래와 같은 비동기 상황에서 2번 뒤에 꼭 3번이, 3번 뒤에  꼭 4번이 실행이 되어야 할 때! 그런 경우 필요합니다.   console.log('1번'); setTimeout( ()=&gt; console.log('2번'), 0); console.log('3번'); setTimeout( ()=&gt; console.log('4번'), 0); setTimeout( ()=&gt; console.log('5번'), 0); console.log('6번');   1 2 3 4 5 6 1번 3번  6번 2번 4번  5번   동기방식이기 때문에 1번이 끝날 때까지 2번은 시작할 수 없습니다. 이를 Promise를 통한 비동기 식으로 바꾼다면 아래와 같이 적용하면 됩니다.   const logGet = ( param, resolve ) =&gt; {          console.log(`${param}`);          resolve();     };  const getpromise = (param) =&gt; {     return new Promise ( ( resolve, resject ) =&gt;{         setTimeout( ()=&gt; {             console.log(`${param}`);             resolve( resolve );         }, 0);     }) }  new Promise(( resolve, resject ) =&gt; {         logGet('1번', resolve)     })     .then( () =&gt; getpromise('2번'))     .then( (resolve) =&gt; logGet('3번',resolve))     .then( () =&gt; getpromise('4번'))     .then( () =&gt; getpromise('5번'))     .then( (resolve) =&gt; logGet('6번',resolve))   1 2 3 4 5 6 1번 2번  3번 4번 5번  6번   Promise의 큰 틀은 4가지로 존재합니다.      Pending : new Promise();를 호출한 상태 , Fulfilled 전 상태   Fulfilled  : resolve 된 상태   Rejected : reject 된 상태   Settled : 결론이 난 상태   promise는 new를 통해 생성하며 resolve와 reject를 파라메터로 가지는 함수를 받고 있습니다. resolve, resolve는 추후 실행부에게  결과를 알려줄 때 사용됩니다. new를 통해 Promise객체를 만들고 resolve나 reject를 실행되기 전 상태를 pending 상태입니다.   const isGo = true;     const promiseTemp = new Promise( ( resolve, resject ) =&gt;{         if( isGo ){             const nextData = {};         nextData.isgo = true;         resolve( nextData )     } else {         const nextData = {};         nextData.isgo = false;         resject( nextData );     } })  위와 같이 선언한 Promise를 실행하는 부분을 짜보겠습니다.   const isGo = true; const promiseTemp = new Promise( ( resolve, resject ) =&gt;{     if( isGo ){         const nextData = {};         nextData.isgo = true;         resolve( nextData )     } else {         const nextData = {};         nextData.isgo = false;         resject( nextData );     } })  promiseTemp.then(     ( resultData )=&gt;{         // 성공시 부분입니다.         console.log('성공');         console.log(resultData);     },     (resultData)=&gt;{         // 실패시 부분입니다.         console.log('실패');         console.log(resultData);     } )   1 2 성공 index.html:36 {isgo: true}   isGo를 true, false로 바꾸면서 해보시면 이해가 됩니다.       만약 여러 promise를 사용한 채 실패에 대한 출력 내용이 같을 경우 catch를 통해 처리한다면 간편합니다. finally은 resolve가 되던, reject이되던  결과에 상관없이 동작할 때 유용합니다.   const logGet = ( param, resolve ) =&gt; {          if(param === '3번'){             throw new Error(\"에러가 발생했습니다.\");         } else {             console.log(`${param}`);              resolve();         }              };  const getpromise = (param) =&gt; {     return new Promise ( ( resolve, resject ) =&gt;{         setTimeout( ()=&gt; {             console.log(`${param}`);             resolve( resolve );         }, 0);     }) }  new Promise(( resolve, resject ) =&gt; {         logGet('1번', resolve)     })     .then( () =&gt; getpromise('2번'))     .then( resolve =&gt; logGet('3번',resolve))     .then( () =&gt; getpromise('4번'))     .then( () =&gt; getpromise('5번'))     .then( resolve =&gt; logGet('6번',resolve))     .catch( error =&gt; console.log( error.message ) )     .finally( () =&gt; console.log('end') );   1 2 3 4 1번 2번 에러가 발생했습니다. end   참고자료     – EMCAScript6 - 김영보 지음   ","categories": ["Javascript"],
        "tags": ["ES6"],
        "url": "https://minesafety-eng.github.io//javascript/javascript-ecmascript6/",
        "teaser":null},{
        "title": "테스트글1",
        "excerpt":"테스트글 1을 작성해본다.   헤딩2     글을 작성하는 것도 내게 쉽지 않다. 세상 쉬운 것이 하나 없다지만, 내 속을 드러내는 일은 더더욱 힘들다. 그렇지만, 지금부터 작성할 글은 나에 대한 이야기가 아니다. 교재와 공식을 토대로 풀이를 작성하는 일이기 때문에부담을 버리고 하나씩 시도해보고자 한다. 세상을 향해 한 걸음 내딛는 계기가 되길.   헤딩3   마크다운 문법은 나에게 너무 어색하다. 다만, 한 가지 희망적인 부분이 있다면 계산식을 넘 편하게 작성할 수 있기 때문 아닐까? 매스잭스나   헤딩3   왜 목차는 안 나타나는 거지?   테스트글 1을 작성해본다.   헤딩2     글을 작성하는 것도 내게 쉽지 않다. 세상 쉬운 것이 하나 없다지만, 내 속을 드러내는 일은 더더욱 힘들다. 그렇지만, 지금부터 작성할 글은 나에 대한 이야기가 아니다. 교재와 공식을 토대로 풀이를 작성하는 일이기 때문에부담을 버리고 하나씩 시도해보고자 한다. 세상을 향해 한 걸음 내딛는 계기가 되길.   헤딩3   마크다운 문법은 나에게 너무 어색하다. 다만, 한 가지 희망적인 부분이 있다면 계산식을 넘 편하게 작성할 수 있기 때문 아닐까? 매스잭스나   헤딩3   왜 목차는 안 나타나는 거지?   테스트글 1을 작성해본다.   헤딩2     글을 작성하는 것도 내게 쉽지 않다. 세상 쉬운 것이 하나 없다지만, 내 속을 드러내는 일은 더더욱 힘들다. 그렇지만, 지금부터 작성할 글은 나에 대한 이야기가 아니다. 교재와 공식을 토대로 풀이를 작성하는 일이기 때문에부담을 버리고 하나씩 시도해보고자 한다. 세상을 향해 한 걸음 내딛는 계기가 되길.   헤딩3   마크다운 문법은 나에게 너무 어색하다. 다만, 한 가지 희망적인 부분이 있다면 계산식을 넘 편하게 작성할 수 있기 때문 아닐까? 매스잭스나   헤딩3   왜 목차는 안 나타나는 거지?   테스트글 1을 작성해본다.   헤딩2     글을 작성하는 것도 내게 쉽지 않다. 세상 쉬운 것이 하나 없다지만, 내 속을 드러내는 일은 더더욱 힘들다. 그렇지만, 지금부터 작성할 글은 나에 대한 이야기가 아니다. 교재와 공식을 토대로 풀이를 작성하는 일이기 때문에부담을 버리고 하나씩 시도해보고자 한다. 세상을 향해 한 걸음 내딛는 계기가 되길.   헤딩3   마크다운 문법은 나에게 너무 어색하다. 다만, 한 가지 희망적인 부분이 있다면 계산식을 넘 편하게 작성할 수 있기 때문 아닐까? 매스잭스나   헤딩3   왜 목차는 안 나타나는 거지?   테스트글 1을 작성해본다.   헤딩2     글을 작성하는 것도 내게 쉽지 않다. 세상 쉬운 것이 하나 없다지만, 내 속을 드러내는 일은 더더욱 힘들다. 그렇지만, 지금부터 작성할 글은 나에 대한 이야기가 아니다. 교재와 공식을 토대로 풀이를 작성하는 일이기 때문에부담을 버리고 하나씩 시도해보고자 한다. 세상을 향해 한 걸음 내딛는 계기가 되길.   헤딩3   마크다운 문법은 나에게 너무 어색하다. 다만, 한 가지 희망적인 부분이 있다면 계산식을 넘 편하게 작성할 수 있기 때문 아닐까? 매스잭스나   헤딩3   왜 목차는 안 나타나는 거지?   테스트글 1을 작성해본다.   헤딩2     글을 작성하는 것도 내게 쉽지 않다. 세상 쉬운 것이 하나 없다지만, 내 속을 드러내는 일은 더더욱 힘들다. 그렇지만, 지금부터 작성할 글은 나에 대한 이야기가 아니다. 교재와 공식을 토대로 풀이를 작성하는 일이기 때문에부담을 버리고 하나씩 시도해보고자 한다. 세상을 향해 한 걸음 내딛는 계기가 되길.   헤딩3   마크다운 문법은 나에게 너무 어색하다. 다만, 한 가지 희망적인 부분이 있다면 계산식을 넘 편하게 작성할 수 있기 때문 아닐까? 매스잭스나   헤딩3   왜 목차는 안 나타나는 거지?   테스트글 1을 작성해본다.   헤딩2     글을 작성하는 것도 내게 쉽지 않다. 세상 쉬운 것이 하나 없다지만, 내 속을 드러내는 일은 더더욱 힘들다. 그렇지만, 지금부터 작성할 글은 나에 대한 이야기가 아니다. 교재와 공식을 토대로 풀이를 작성하는 일이기 때문에부담을 버리고 하나씩 시도해보고자 한다. 세상을 향해 한 걸음 내딛는 계기가 되길.   헤딩3   마크다운 문법은 나에게 너무 어색하다. 다만, 한 가지 희망적인 부분이 있다면 계산식을 넘 편하게 작성할 수 있기 때문 아닐까? 매스잭스나   헤딩3   왜 목차는 안 나타나는 거지?   테스트글 1을 작성해본다.   헤딩2     글을 작성하는 것도 내게 쉽지 않다. 세상 쉬운 것이 하나 없다지만, 내 속을 드러내는 일은 더더욱 힘들다. 그렇지만, 지금부터 작성할 글은 나에 대한 이야기가 아니다. 교재와 공식을 토대로 풀이를 작성하는 일이기 때문에부담을 버리고 하나씩 시도해보고자 한다. 세상을 향해 한 걸음 내딛는 계기가 되길.   헤딩3   마크다운 문법은 나에게 너무 어색하다. 다만, 한 가지 희망적인 부분이 있다면 계산식을 넘 편하게 작성할 수 있기 때문 아닐까? 매스잭스나   헤딩3   왜 목차는 안 나타나는 거지?   ","categories": [],
        "tags": [],
        "url": "https://minesafety-eng.github.io//test1/",
        "teaser":null}]
